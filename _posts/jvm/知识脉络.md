1. 内存模型
2. 垃圾收集器和内存分配策略
   1. 垃圾收集就是GC
   2. 对象存活判定算法
      1. 引用计数算法 
         1. 给对象添加一个引用计数器，有地方引用它时，计数器就加一，当引用失效时就减一。
         2. 很难解决对象之间相互循环引用的问题
         3. 主流的虚拟机没有选用该算法
      2. 可达性分析算法
         1. 通过一系列称为“GC ROOT”的对象做为起点，从这些节点往下搜索，搜索走过的路径称为引用链。当衣蛾对象到GC ROOTs没有任何引用链相连时候，证明对象不可用。
         2. 可作为GC ROOTS的对象有以下几种：
            1. 虚拟机栈（栈帧中的本地变量表）中引用的的对象
            2. 方法区中类静态属性引用的对象
            3. 方法区中常量引用的对象
            4. 本地方法栈中JNI（即一般说的Native方法）引用的对象

3. 引用

   1. 强引用
      1. 就是Object obj = new Object();
      2. 垃圾回收区永远不会回收被引用的对象
   2. 软引用
      1. SoftReference类来实现软引用
      2. 软引用关联的对象之后再系统将要发生内存溢出异常之前会被防砸回收范围之中进行第二次回收。如果这次回收还是没有足够空间，才会跑出内存溢出异常。
   3. 弱引用
      1. WeakReference类来实现弱引用
      2. 弱引用关联的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作的时候，无论当前内存是否足够都会被回收掉。
   4. 虚引用
      1. PhantomReference类来实现虚引用
      2. <font color="red">一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</font>
   5. 四种引用一次逐渐减弱

4. 垃圾收集算法

   1. 标记-清除算法

      两个阶段：标记和清除

   2. 复制算法

   3. 标记-整理算法

   4. 分代收集算法

5. 垃圾回收器

   | 适用的区域 |               |                   |           |
   | ---------- | ------------- | ----------------- | --------- |
   | 新生代     | Serial GC     | Parallel Scavenge | ParNew GC |
   | 老年代     | Serial Old GC | Parallel Old GC   | CMS       |
   | 其他       | G1            |                   |           |

   串行回收器： `Serial` 、`Serial Old`
   并行回收器： `ParNew`、`Parallel Scavenge`、 `Parallel Old`
   并发回收器： `CMS`、 `G1`

