---
layout: article
title: Spring
mathjax: true
tags: Spring
key: 2019-06-19
categories:
- Spring
- 源码
---
# Spring源码

## 1.IOC
存放对象的容器

如何存储容器对象使用key-value结构

对象是谁创建？容器

对象如何创建？new 工厂 反射的方式

```java
Class clazz = Person.class;
Constructor ctor = clazz.getConstructor();
Object person = ctor.newInstance();
```

xml与注解只要是为了解决bean定义信息（beandefine）

- 对象默认是单例，可以配置成非单例

名词：

- bean定义信息（BeanDefinition），一个spring的概念

- 读取器（BeanDefinitionReader），一个spring的概念，读取BeanDefinition放到容器中去

- bean工厂（BeanFactory）

对象的创建的两个概念：

- 实例化：最主要的是在堆中开启一块空间，属性有默认值
- 初始化：
  - 属性赋值
  - 初始化方法

- 实例化之后要初始化，才会生成一个完整的对象

postprocessor 后置处理器（增强器）：多xml，没有xml都需要一个公有的值，



# 循环依赖的问题

- 什么是循环依赖
- spring中如何解决循环依赖问题
- 为什么要使用三级缓存解决循环依赖问题？一级缓存行不行？二级缓存行不行？

## 解答循环依赖

下边所说的前提：创建的所有对象都是单例对象

循环依赖问题：

如果是构造器方式没有办法解决

如果是setter方式可以使用三级缓存方式解决

三级缓存就是三个map，区别是在他们的value类型

其中三级缓存singletonFactories

```java
@FunctionalInterface
public interface ObjectFactory<T> {

	/**
	 * Return an instance (possibly shared or independent)
	 * of the object managed by this factory.
	 * @return the resulting instance
	 * @throws BeansException in case of creation errors
	 */
	T getObject() throws BeansException;

}
```

实际执行匿名内部类

提前暴露对象

从一级缓存 二级缓存 三级缓存

### 为什么非要用三级缓存？二级缓存行不行？以及行不行？

一级缓存中会放置完整的对象或者非完整对象，如果在操作的时候恰巧获取到非完全对象怎么办？

一级缓存放完整对象，二级缓存放非完整对象，

### 在创建代理对象的时候，需不需要提前创建出属性是默认值的普通对象？

一定会创建出普通对象



当需要创建代理对象的时候，需要执行一个lambda表达式来创建代理类，如果没有三级缓存的话，就有可能有一种情况，刚开始县创建出普通对象，然后被调用了，后续又需要代理对象，此时生成，那么最终使用的效果是有些使用普通对象有些使用代理对象

**如果没有aop的实现的话，二级缓存就可以了。三级缓存可以解决aop的代理类问题**
