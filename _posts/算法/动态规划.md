---
layout: article
title: 动态规划
mathjax: true
tags: 动态规划 算法
key: 2019-01-01
categories:
- 算法

---

# 一、四种模型

## 1.从左往右尝试模型1

题目：规定1和A对应、2和B对应、3和C对应........26和Z对应

那么一个数字字符串比如“111”就可以转化为“AAA”、”KA“、”AK“

给定一个只有数字字符组成的字符串str，返回有多少种转化结果？

```java
		/**
     *
     * @param str 需要统计的char数组
     * @param i i位置之前不包括i位置，char数组已经做过统计。那么统计一下i位置包括i位置以及往后的char的转化结果；就是说是从i这个位置上还是计算还有哪几种结果
     * @return
     */
    public static int process(char[] str, int i) {
        //将数组str放在数组（数组A）中,str是从数组A的0位置开始，将所有的元素放在A中，其中i代表数组A的下标；
        // 该算法的思路就是，遍历数组A，然后按照某一个路径将对应的str的元素都遍历完，那么这条路径就是一种结果。
        // 因为是一个元素一个元素按个遍历的所以可以使用一直往下遍历的方法直到遍历的i=str的长度的时候就能代表这条路径遍历完了。然后记录1，代表这一条路径。
        if (i == str.length) {
            return 1;
        }
        // i位置上的元素作为组合或者是自己进行转化的时候是否可以充当第首位，如果不能就放在
        if (str[i] == '0') {
            return 0;
        }
        // process(str, i + 1)说明的意思是，该条路径在i这个位置上是转化的时候是没有问题的，因为不需要记录路径的详情只记录最终遍历完的树的个数，所以就用i+1
        // 跳过i然后用process去找从i+1开始的字符串的路径
        // process(str, i + 2) 就说的是 i和i+1组合成一个两位的字符去转换是没有问题的，然后执行process(str, i + 2)去找i+2开始的字符串路径转换方式
        // 为什么之后i+1和i+2呢？就是因为，数组的元素是一位0到9而用0到9的字符转化A到Z的时候一位或者是两位，故而如此，联想如果转化是3位的话就需要再去找i+3开始的字符串的转化方式了
        if (str[i] == '1') {
            int res = process(str, i + 1);
            if (i + 1 < str.length) {
                res += process(str, i + 2);
            }
            return res;
        }
        if (str[i] == '2') {
            int res = process(str, i + 1);
            if (i + 1 < str.length && (str[i + 1] > '0' && str[i + 1] <= '6')) {
                res += process(str, i + 2);
            }
            return res;
        }
        return process(str, i + 1);
    }
```







