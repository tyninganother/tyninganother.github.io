---
layout: article
title: 算法目录
mathjax: true
tags: 算法目录
key: 2019-01-01
categories:
- 算法
---

# 一、评估流程复杂度的核心指标是什么？

- 时间复杂度（流程决定）

- 额外空间复杂度（流程决定） 

  实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

  作为输入参数的空间，不算额外空间

  作为输出结果的空间，也不算额外空间

  因为这些都是必要的、和实现目标有关的。所以都不算。

  但是除此之外，你的流程如果还需要开辟空间才能让你的额流程继续下去。这部分空间就是额外空间。

  如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)

- 常数项时间（实现细节决定）

  使用样本来做，用一个大的样本跑出结果看

**Tip: 想要讲清楚这几个指标得先搞清楚常数时间的操作，因为分析一个流程的复杂度的话必须要将流程转换成常数时间操作，然后计算常数时间操作的次数与N的关系。**

# 二、常见的常数时间的操作

- 常见的算数运算（+、-、*、%、/）
- 位运算（>>>,>>,<<,&,|,^等）:
  - ">>":是带符号位右移一位。最高位的补充是按照符号位来补充的。比如：100010，>>之后就是110001
  - ">>>" : 是不带符号位右移一位。最高位使用0来补充
- 复制、比较、自增、自减操作等
- 数组寻址操作

非常数时间操作：比如LinkedList底层是一个双向链表，list.get(i)就不是

# 三、时间复杂度

## 3.1.如何确定算法流程的时间复杂度？

当完成了表达式的监理，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。比如计算出来的公式是 $2N^2+2N+3$ 那么选取最高阶项，去除常数参数和常数项以及低阶项，就是$N^2$,那么时间复杂度就是$N^2$。高阶项确定算法的瓶颈。

记为：O(去掉系数的高阶项)  **表示最差情况下的复杂度**

## 3.2.如何确定算法流程的总操作数量与样本数量之间的表达式关系？

1. 想想该算法流程所处理的数据状况，要按照组差情况来。
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
3. 如果数据数量为N，看看基本动作的数量和N是什么关系



# 四、常见的算法

1. **选择排序** 从左往右，找到除0位置的其他书的最小值，然后与第0位置上的元组进行交换，然后周而复始。效果就是从左往右依次将最小值填满。 $N^2$。
2. **冒泡排序**  从左往右，每相邻两个位置上的元素比较，如果左边大于右边就交换位置否则不交换。第一遍的结果就是最后一位是最大的数字。然后周而复始直到遍历了了N次，达到从小到大排序。效果就是想将最右一位排好，然后最右N-1位置排好。$N^2$。
3. **插入排序** 从左往右，看0~0位置有序，因为是一个数字所以不用动。然后看0 ~ 1位置有序，因为1位置是在0 ~ 0结果的基础上进行操作的，那么就用1和0 ~ 0的数组，从右往左，一个一个数字的比较如果1位置的数字比比较的数字小我们就交换，然后再和前一位的数字比较，如果比比较的元素小的话就做交换。周而复始。$N^2$。
4. **二分法** （$O(logN)$）
   1. 有序数组中，找某个数
   2. 有序数组中，找>=某个数最左侧的位置
   3. 有序数组中，找<=某个数最左侧的位置
   4. 局部最小值问题



常见的一些位运算的写法：

$ N*2 $ 写成 $N<<1$

$N*2+1$写成$(N<<1)|1$



# 五、常见的时间复杂度

排名好到差：

$O(1)$

$O(logN)$

$O(N)$

$O(N*logN)$

$O(N^2)$$O(N^3)$$O(N^4)$........

$O(2^N)$$O(3^N)$$O(4^N)$........

$O(N!)$

# 六、算法和数据结构学习的大脉络

1）知道怎么算的算法

2）知道怎么试的算法

# 七、认识对数器



# 八、位运算

## 8.1 异或运算

- 特性
  - 0^N == N N^N==0
  - 异或运算满足交换律和结合律
  - 相同为0不同为1

异或运算的特点就是二进制两位相加不进位计算出来的值

1. int a= A;int b=B 然后进行操作让a和b的值进行交换。

   a=a^b a=a^b a=a^b 然后 a=B b=A；**一定要注意a和b是不是同一个内存区域，如果是一个的话，那么a=a^b其实就是将a和b使用的这一个内存区域的值都变了，所以执行了这个语句之后，其实a的值改变了b的值也改变了。**

## 位运算的常规技巧

题目三

怎么把一个int类型的数，提取出最右侧的1来

使用常规操作公式N & ((~N)+1) ​，其实原理很简单，就是将N取反，然后最右的位置之前的0都变成1，然后1都是0如果加上1（就是1000变成0111加上1就变成1000），然后&，就只有最右边的1没有变化其他的位置没有都是1的情况。

题目四

一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数？

这种



借用https://labuladong.gitbook.io/中的思路做的记录，很不错

一、基础

1. 最基础的数据结构，链表和数组（一维数组、多维数组）两种
2. 算法中使用的递归和遍历两种

二、排序

	1. 插入排序
	2. 希尔排布
	3. 堆排序
	4. 归并排序
	5. 快排序
	6. 桶排序
	7. 外部排序

三、算法设计技巧

1. 贪心算法
2. 分治算法
3. 回溯算法
4. 动态规划
5. 随机化算法



1. 目的求最值
2. 求最值的核心问题就是穷举
3. 解决穷举慢的问题可以从“重叠子问题”开始，一定会有“最优子结构”，先求出最优子结构的最值，然后再求这些“小”最值集合的最值。



![image-20201111170443603](https://tyninganother.github.io/assets/image-20201111170443603.png)



![image-20201111171302340](https://tyninganother.github.io/assets/image-20201111171302340.png)

![image-20201111171939337](https://tyninganother.github.io/assets/image-20201111171939337.png)

![image-20201111180543902](https://tyninganother.github.io/assets/image-20201111180543902.png)

