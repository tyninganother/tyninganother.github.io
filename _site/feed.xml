<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="zh" /><updated>2021-04-21T18:21:48+08:00</updated><id>/feed.xml</id><title type="html">Tyning Another</title><subtitle>No
</subtitle><author><name>tyning.another</name></author><entry><title type="html">目录</title><link href="/2019/06/19/zookeeper.html" rel="alternate" type="text/html" title="目录" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>/2019/06/19/zookeeper</id><content type="html" xml:base="/2019/06/19/zookeeper.html">&lt;p&gt;https://zhuanlan.zhihu.com/p/121728783&lt;/p&gt;

&lt;p&gt;docker-compose 搭建zookeeper集群&lt;/p&gt;</content><author><name>tyning.another</name></author><category term="Java" /><summary type="html">https://zhuanlan.zhihu.com/p/121728783 docker-compose 搭建zookeeper集群</summary></entry><entry><title type="html">SpringCloud</title><link href="/springcloud---/2019/06/19/springcloud.html" rel="alternate" type="text/html" title="SpringCloud" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>/springcloud---/2019/06/19/springcloud</id><content type="html" xml:base="/springcloud---/2019/06/19/springcloud.html">&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;要知道什么是现在使用的东西&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用spring cloud 搭建一个系统&lt;/li&gt;
  &lt;li&gt;中间件&lt;/li&gt;
  &lt;li&gt;传统的SSO&lt;/li&gt;
  &lt;li&gt;Oauth2服务 四种授权模式&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;springcloud.assets/image-20210406141548674.png&quot; alt=&quot;image-20210406141548674&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20201130114534127.png&quot; alt=&quot;image-20201130114534127&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20201201140334936.png&quot; alt=&quot;image-20201201140334936&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;分布式微服务架构体系&quot;&gt;分布式微服务架构体系&lt;/h1&gt;

&lt;p&gt;https://www.bilibili.com/video/BV18E411x7eT?p=18&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20201201190523863.png&quot; alt=&quot;image-20201201190523863&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;组件说明&quot;&gt;组件说明&lt;/h1&gt;

&lt;h2 id=&quot;服务注册中心&quot;&gt;服务注册中心&lt;/h2&gt;

&lt;p&gt;Eureka等待总结：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最终的结果就是有什么样子的微服务表。如果不在的话就直接移除，如果有的话就添加到表单中。&lt;/li&gt;
  &lt;li&gt;注册中心的一个服务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Eureka 不在更新&lt;/p&gt;

&lt;p&gt;老技术Zookeeper&lt;/p&gt;

&lt;p&gt;还有一个是Consul&lt;/p&gt;

&lt;p&gt;阿里巴巴的那个是Nacos，这个推荐使用&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 什么是服务治理？主要的目的是为了实现服务调用、负载均衡、容错等，实现服务的注册与发现
2. 什么是服务注册？
3. Eureka有两个组件：Eureka-server（各个微服务节点通过配置启动后会在server中进行注册，server的服务注册表中会存储所有注册的服务） Eureka-client（客户端中有一个轮训负载算法的负载均衡器，回想server发送心跳，如果server多个心跳周期没有收到某个节点的心跳信号的话，服务将会被从server中移除）
4. Eureka 1.X 和2.X的区别：pom的引用不一样了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;服务调用&quot;&gt;服务调用&lt;/h2&gt;

&lt;p&gt;一、 Ribbon的讲解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;负债均衡工具&lt;/li&gt;
  &lt;li&gt;是&lt;strong&gt;客户端&lt;/strong&gt;的负载均衡工具&lt;/li&gt;
  &lt;li&gt;是&lt;strong&gt;软&lt;/strong&gt;负债均衡的客户端工具&lt;/li&gt;
  &lt;li&gt;负债均衡的英文缩写是&lt;strong&gt;LB&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、一个小问题：负债均衡的分类是集中式和进程式Ribbon和Nginx所说的负债均衡的不同点？&lt;/p&gt;

&lt;p&gt;三、Ribbon的说明：会先得得到注册中心中注册的信息服务列表，然后将其缓存到本地的JVM中，然后在客户端本地实现RPC远程调用。&lt;/p&gt;

&lt;p&gt;四、Ribbon功能组成：负载均衡 和接口RPC远程调用两个功能&lt;/p&gt;

&lt;p&gt;五、Ribbon工作步骤：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 先将注册中心中的信息缓存在本地。
2. 然后根据用户指定的负债均衡的策略，然后选择一个地址。
3. 选择一个地址然后进行调用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;六、负债均衡的策略有：轮询、随机、更具时间响应时间加权。&lt;/p&gt;

&lt;p&gt;七、 引入pom包如果使用了新的eureka的升级的的pom引入的话那么就不需要在新的引入了&lt;/p&gt;

&lt;p&gt;八、Ribbon的结构： 负载均衡 + RestTemplate&lt;/p&gt;

&lt;p&gt;九、RestTemplate工具的熟悉&lt;/p&gt;

&lt;p&gt;十、 负债均衡的7种实现（IRule的7中实现）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20210125185409125.png&quot; alt=&quot;image-20210125185409125&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RoundRobinRule：轮询&lt;/p&gt;

&lt;p&gt;RandomRule：随机&lt;/p&gt;

&lt;p&gt;RetryRule：先按照RoundRobinRule（轮询）策略获取服务，如果获取服务失败则在指定时间内进行重试，如果超出重试的最大时间就放弃轮询顺序选择下一个链接，然后不停的重复这个规则然后直到获取可用的服务；（&lt;strong&gt;如果轮询的时候出现都不可用的服务该如何处理&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;BestAvailableRule：遍历所有服务，先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务，如果所有服务的这两个指标的都一样的话就使用RoundRobinRule选择一个。&lt;/p&gt;

&lt;p&gt;AvailabilityFilteringRule：会先过滤掉由于多次访问故障而处于断路器状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问；&lt;/p&gt;

&lt;p&gt;WeightedResponseTimeRule：对RoundRobinRule的扩展，先使用RoundRobinRule进行轮询，然后响应速度越快的示例选择全中遇到，越容易被选择&lt;/p&gt;

&lt;p&gt;ZoneAvoidanceRule&lt;/p&gt;

&lt;p&gt;十一、Ribbon自定义规则 这里边的三个原理需要补充&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20210208143336464.png&quot; alt=&quot;image-20210208143336464&quot; /&gt;&lt;/p&gt;

&lt;p&gt;https://www.bilibili.com/video/BV18E411x7eT?p=38&lt;/p&gt;

&lt;p&gt;Ribbon 停止更新现在还可以使用&lt;/p&gt;

 	1. 是客户端负载均衡工具，提供客户端的负债均衡的算法和服务调用。还可以配置链接超时什么的链接中的一些配置与方法。httpclient的封装，和eureka的配合调用工具等。
 	  	1. 负载均衡（LB）分为两种： &lt;strong&gt;集中式LB；进程内LB&lt;/strong&gt;。那么ngix与ribbon的区别：ribbon是本地负载均衡，是进程内LB；ngix是服务器的负载均衡是集中式LB
 	  	2. 最后总结什么是Ribbon？本地负载均衡+restTemplate调用
 	  	3. 软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合知识其中的一个实例。
 	2. Ribbon在工作室分为两步
 		1. 第一步先选择EurekaServer，他优先选择在同一个区域内如在较少的server
 		2. 第二部在根据用户指定的策略，在从server渠道的服务注册列表中选择一个地址
 	3. Ribbon提供了多种负载均衡策略：轮训、随机和根据响应时间加权重
 	4. Ribbon在cloud-client新版中被继承。

&lt;p&gt;LoadBalancer 这个也可以用但是出来的时间不长&lt;/p&gt;

&lt;h2 id=&quot;服务调用2&quot;&gt;服务调用2&lt;/h2&gt;

&lt;p&gt;Feign 不要用了&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Feign是一个声明式的Web服务客户端，说白了就是一个微服务接口与java声明式接口绑定的工具&lt;/li&gt;
  &lt;li&gt;一个接口被多次调用，所以通常都会针对每个微服务自行分装一些客户端类来包装这些依赖服务的调用。所以feign的实现下，我们只需要创建一个接口并使用注解的方式配置大就可以完成对服务方的接口绑定。&lt;/li&gt;
  &lt;li&gt;Feign内置了Ribbon。使用Feign定义的注解，调用这个接口就能调动注册中心的服务&lt;/li&gt;
  &lt;li&gt;用在消费方&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;OpenFeign 社区提供的Feign&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;是在Feign的基础之上支持了SpringMVC的注解，然后通过动态代理的方式产生实现类，实现类中做负载均衡并调动服务&lt;/li&gt;
  &lt;li&gt;OpenFeign的实现：微服务调用接口+@FeignClient 第一步在需要调用的springboot启动类中添加@EnableFeignClients，然后在service接口中添加@Component和@FeignClient(value = “PAYMENT-SERVER”) 其中value是微服务的名字。方法上使用@GetMappingspringMVC的注解，这样就可以使用service中调用了。&lt;/li&gt;
  &lt;li&gt;消费者调用服务方的服务时候是通过网络服务所以需要考虑链接超时问题。其中OpenFeign默认超时是1秒钟，如果调用的服务接口1秒钟没有返回就会超时报错。如果想要定制这个1秒钟的超时为其他的话就需要在yml中修改配置。以为OpenFeign底层使用的是ribbon来实现负载均衡的所有这个超时配置修改，是修改的是ribbon的超时间配置。在yml中添加ribbon:ReadtimeOut：5000 ConnectTimeOut：5000&lt;/li&gt;
  &lt;li&gt;OpenFeign提供了日志打印功能，可以答应feign请求http的详细情况。日志级别是可以设置的有四种NONE默认不打印日志；BASIC:仅记录请求方法、URL、响应状态码以及执行时间；HEADERS。除了BASIC中定义的信息外还有请求的响应的头信息；FULL:除了HEADERS中定义的信息，还有请求和响应的正文以及元数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;服务降级&quot;&gt;服务降级&lt;/h2&gt;

&lt;p&gt;Hystrix 不再用了，停止更新了&lt;/p&gt;

&lt;p&gt;问题出现的场景：微服务越来越多，微服务的依赖也越来越多。如果在调用链路上的一个或者多个节点出现问题之后，该如何保证服务的正常运行，这个Hystrix框架就是用来解决这种情况的。&lt;/p&gt;

&lt;p&gt;一、定义：&lt;/p&gt;

&lt;p&gt;​	Hystrix是一个分布式系统的延迟和容错的开源库。在两路中一个依赖出现问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性&lt;/p&gt;

&lt;p&gt;二、能够处理问题的方法：服务熔断和服务降级以及接近实时的监控、限流、隔离&lt;/p&gt;

&lt;p&gt;三、第“二”条中的概念&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务降级（fallback）
    &lt;ol&gt;
      &lt;li&gt;如果调用的服务出现异常，向调用方返回一个符合预期的可处理的备选响应（Fallback）&lt;/li&gt;
      &lt;li&gt;哪些情况会触发降级呢？
        &lt;ol&gt;
          &lt;li&gt;程序运行异常&lt;/li&gt;
          &lt;li&gt;请求超时异常&lt;/li&gt;
          &lt;li&gt;服务熔断触发服务降级&lt;/li&gt;
          &lt;li&gt;线程池或者信号量打满也会导致服务降级&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;服务熔断（break）
    &lt;ol&gt;
      &lt;li&gt;先将服务断掉，然后调用服务降级的方法并返回友好提示&lt;/li&gt;
      &lt;li&gt;处理过程：服务的降级-&amp;gt;进而熔断-&amp;gt;恢复调用链路&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;服务限流（flowlimit）
    &lt;ol&gt;
      &lt;li&gt;如果对于一个服务来说如果一个高并发过来流量拥挤，然后就让这个大流量排队，按照服务能够处理的能力来排队处理&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;四、产生服务降级的问题，以及如何解决下边三个维度&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;超时导致服务器变慢-》超时不再等待&lt;/li&gt;
  &lt;li&gt;出错（调用服务宕机或者程序运行出错）-》要有兜底的逻辑&lt;/li&gt;
  &lt;li&gt;如果对方服务是ok的但是业务要求调用方需要被调用的服务在有效时间内给出答案如果不行的话需要服务降级处理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;五、服务降级的配置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以使用注解也可以使用类继承，这里直接说注解的使用@HystrixCommand。在微服务的启动类上添加该注解。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;https://www.bilibili.com/video/BV18E411x7eT?p=54&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;降级有两种一种是自己对自己的降级，就是监控自己的一个方法，如果方法报错的话要有一个兜底的处理方法（服务端降级保护）。另外一种就是如果调用其他微服务的时候报错，那么对返回的错误或者等不到的时候就做其他兜底方法处理（客户端降级保护）&lt;/li&gt;
  &lt;li&gt;自定义和全局的降级处理，在接口类上边直接用一个@defaultProperties 然后定义一个defaultFallback方法。&lt;/li&gt;
  &lt;li&gt;还可以使用@feiClint中的defaultFallBack类，指定一个实现了interface类，让指定的实现的interface的类，然后重载实现所有方法，并写去处理逻辑&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;六、服务熔断&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20210209151412136.png&quot; alt=&quot;image-20210209151412136&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先关闭服务然后返回提示&lt;/li&gt;
  &lt;li&gt;断路器 open closed half-open&lt;/li&gt;
  &lt;li&gt;请求次数是否达到了峰值&lt;/li&gt;
  &lt;li&gt;涉及到断路器的三个重要参数：快照时间窗、请求总数阈值、错误百分比&lt;/li&gt;
  &lt;li&gt;断路器关闭的条件：
    &lt;ol&gt;
      &lt;li&gt;当满足一定的阈值的时候&lt;/li&gt;
      &lt;li&gt;当失败率达到一定的时候&lt;/li&gt;
      &lt;li&gt;达到以上法制断路器将会开启&lt;/li&gt;
      &lt;li&gt;当开启的时候所有请求都不会进行转发&lt;/li&gt;
      &lt;li&gt;一段时间之后这个时候断路器是搬开状态会让其中一个请求进行转发如果陈宫断路器会关闭如失败，继续开启重复4和5&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;工作流程需要总结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;七、服务限流&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在sentinel进行讲解&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;服务雪崩问题
    &lt;ol&gt;
      &lt;li&gt;“扇出”结构：说的就是多个微服务之间的调用，如果微服务A调用B，B有调用C，C和B有调用其他微服务&lt;/li&gt;
      &lt;li&gt;如果扇出来的链路上某个微服务的调用时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃。这个现象叫做雪崩效应&lt;/li&gt;
      &lt;li&gt;对于高流量应用来说，单一的后端依赖可能会导致所有服务器上的资源都在几秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。&lt;strong&gt;这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或者系统&lt;/strong&gt;。&lt;/li&gt;
      &lt;li&gt;通常当你法相一个模块下的某个实力失败后，这时候这个模块一样还会接受流量，然后这个有问题的模块还调用了其他模块，这样就发生级联故障，或者叫雪崩。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Hystrix是一个处理分布式系统&lt;strong&gt;延迟&lt;/strong&gt;和&lt;strong&gt;容错&lt;/strong&gt;的开元库，在分布式系统里，许多依赖不可避免的会调用失败，比如超市、异常等，Hystrix能够保证在一个依赖出现问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。&lt;/li&gt;
  &lt;li&gt;Hystrix就是一个“断路器”，当某个服务单元发生故障之后，通过断路器的故障监控，&lt;strong&gt;向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者跑出调用方无法处理的异常&lt;/strong&gt;，这样就保证了调用方的线程不会备长时间、不必要的张勇虫儿避免了故障在分布式系统中的蔓延，乃至雪崩。
4.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;resilience4j 国外推荐使用&lt;/p&gt;

&lt;p&gt;Sentinel 国内推荐，阿里巴巴&lt;/p&gt;

&lt;h2 id=&quot;服务网关&quot;&gt;服务网关&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20201209170703442.png&quot; alt=&quot;image-20201209170703442&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zuul 不再维护&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;p&gt;gateway spring自己出的&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;异步非阻塞模型&lt;/li&gt;
  &lt;li&gt;getway具有如下特点：
    &lt;ol&gt;
      &lt;li&gt;基于spring framkework5，project reactor，spring boot2.0 构建的&lt;/li&gt;
      &lt;li&gt;动态路由：能够匹配任何请求属性&lt;/li&gt;
      &lt;li&gt;可以对路由指定断言和过滤器&lt;/li&gt;
      &lt;li&gt;集成Hystrix的断路器功能&lt;/li&gt;
      &lt;li&gt;集成spring cloud 服务发现功能&lt;/li&gt;
      &lt;li&gt;易于编写的断言和filter&lt;/li&gt;
      &lt;li&gt;请求限流功能&lt;/li&gt;
      &lt;li&gt;支持路径重写&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;spring cloud的Finchley正式版本之前都推荐Zuul
    &lt;ol&gt;
      &lt;li&gt;Zuul1.x使用的是一个基于阻塞I/O的API 网关
2.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一、gateway&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于webflux框架实现 webflux使用的netty&lt;/li&gt;
  &lt;li&gt;目标提供统一的路由方式且基于Filter链的方式提供了网关基本功能&lt;/li&gt;
  &lt;li&gt;有什么功能：
    &lt;ol&gt;
      &lt;li&gt;反向代理&lt;/li&gt;
      &lt;li&gt;鉴权&lt;/li&gt;
      &lt;li&gt;流量控制&lt;/li&gt;
      &lt;li&gt;熔断&lt;/li&gt;
      &lt;li&gt;日志监控&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;特性
    &lt;ol&gt;
      &lt;li&gt;动态路由&lt;/li&gt;
      &lt;li&gt;可以对路由指定断言和过滤器&lt;/li&gt;
      &lt;li&gt;继承Hystrix的断路器功能&lt;/li&gt;
      &lt;li&gt;继承String cloud服务发现功能&lt;/li&gt;
      &lt;li&gt;已与编写的断言和过滤器&lt;/li&gt;
      &lt;li&gt;请求限流功能&lt;/li&gt;
      &lt;li&gt;支持路径重写&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;三个重要的部分：
    &lt;ol&gt;
      &lt;li&gt;Route路由&lt;/li&gt;
      &lt;li&gt;Predicate断言&lt;/li&gt;
      &lt;li&gt;Filter过滤器&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;路由映射
1.&lt;/li&gt;
  &lt;li&gt;网关也是一个微服务&lt;/li&gt;
  &lt;li&gt;如何进行路由配置
    &lt;ol&gt;
      &lt;li&gt;使用yml进行配置&lt;/li&gt;
      &lt;li&gt;如果yml配置太多可以使用硬编码配置使用bean&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;https://www.bilibili.com/video/BV18E411x7eT?p=70&amp;amp;spm_id_from=pageDriver&lt;/p&gt;

&lt;h2 id=&quot;服务配置&quot;&gt;服务配置&lt;/h2&gt;

&lt;p&gt;config 现在不再使用了&lt;/p&gt;

&lt;p&gt;可以使用Nacos&lt;/p&gt;

&lt;h2 id=&quot;服务总线&quot;&gt;服务总线&lt;/h2&gt;

&lt;p&gt;Bus 现在不用了&lt;/p&gt;

&lt;p&gt;携程还有一个appllo也用起来不错&lt;/p&gt;

&lt;p&gt;可以使用Nacos&lt;/p&gt;

&lt;h1 id=&quot;微服务问题&quot;&gt;微服务问题&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;CAP问题&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;CAP定理：
       指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。&lt;/li&gt;
      &lt;li&gt;可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求
4.&lt;/li&gt;
      &lt;li&gt;qps(每秒访问量)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;p&gt;Seata 服务  shardingsphere&lt;/p&gt;

&lt;p&gt;https://www.infoq.cn/article/w6wkhscktpa3-qmqi4gr&lt;/p&gt;</content><author><name>tyning.another</name></author><category term="SpringCloud---" /><category term="SpringCloud" /><summary type="html"># 要知道什么是现在使用的东西 使用spring cloud 搭建一个系统 中间件 传统的SSO Oauth2服务 四种授权模式 分布式微服务架构体系 https://www.bilibili.com/video/BV18E411x7eT?p=18 组件说明 服务注册中心 Eureka等待总结： 最终的结果就是有什么样子的微服务表。如果不在的话就直接移除，如果有的话就添加到表单中。 注册中心的一个服务 Eureka 不在更新 老技术Zookeeper 还有一个是Consul 阿里巴巴的那个是Nacos，这个推荐使用 1. 什么是服务治理？主要的目的是为了实现服务调用、负载均衡、容错等，实现服务的注册与发现 2. 什么是服务注册？ 3. Eureka有两个组件：Eureka-server（各个微服务节点通过配置启动后会在server中进行注册，server的服务注册表中会存储所有注册的服务） Eureka-client（客户端中有一个轮训负载算法的负载均衡器，回想server发送心跳，如果server多个心跳周期没有收到某个节点的心跳信号的话，服务将会被从server中移除） 4. Eureka 1.X 和2.X的区别：pom的引用不一样了 服务调用 一、 Ribbon的讲解： 负债均衡工具 是客户端的负载均衡工具 是软负债均衡的客户端工具 负债均衡的英文缩写是LB 二、一个小问题：负债均衡的分类是集中式和进程式Ribbon和Nginx所说的负债均衡的不同点？ 三、Ribbon的说明：会先得得到注册中心中注册的信息服务列表，然后将其缓存到本地的JVM中，然后在客户端本地实现RPC远程调用。 四、Ribbon功能组成：负载均衡 和接口RPC远程调用两个功能 五、Ribbon工作步骤： 1. 先将注册中心中的信息缓存在本地。 2. 然后根据用户指定的负债均衡的策略，然后选择一个地址。 3. 选择一个地址然后进行调用。 六、负债均衡的策略有：轮询、随机、更具时间响应时间加权。 七、 引入pom包如果使用了新的eureka的升级的的pom引入的话那么就不需要在新的引入了 八、Ribbon的结构： 负载均衡 + RestTemplate 九、RestTemplate工具的熟悉 十、 负债均衡的7种实现（IRule的7中实现） RoundRobinRule：轮询 RandomRule：随机 RetryRule：先按照RoundRobinRule（轮询）策略获取服务，如果获取服务失败则在指定时间内进行重试，如果超出重试的最大时间就放弃轮询顺序选择下一个链接，然后不停的重复这个规则然后直到获取可用的服务；（如果轮询的时候出现都不可用的服务该如何处理） BestAvailableRule：遍历所有服务，先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务，如果所有服务的这两个指标的都一样的话就使用RoundRobinRule选择一个。 AvailabilityFilteringRule：会先过滤掉由于多次访问故障而处于断路器状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问； WeightedResponseTimeRule：对RoundRobinRule的扩展，先使用RoundRobinRule进行轮询，然后响应速度越快的示例选择全中遇到，越容易被选择 ZoneAvoidanceRule 十一、Ribbon自定义规则 这里边的三个原理需要补充 https://www.bilibili.com/video/BV18E411x7eT?p=38 Ribbon 停止更新现在还可以使用 1. 是客户端负载均衡工具，提供客户端的负债均衡的算法和服务调用。还可以配置链接超时什么的链接中的一些配置与方法。httpclient的封装，和eureka的配合调用工具等。 1. 负载均衡（LB）分为两种： 集中式LB；进程内LB。那么ngix与ribbon的区别：ribbon是本地负载均衡，是进程内LB；ngix是服务器的负载均衡是集中式LB 2. 最后总结什么是Ribbon？本地负载均衡+restTemplate调用 3. 软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合知识其中的一个实例。 2. Ribbon在工作室分为两步 1. 第一步先选择EurekaServer，他优先选择在同一个区域内如在较少的server 2. 第二部在根据用户指定的策略，在从server渠道的服务注册列表中选择一个地址 3. Ribbon提供了多种负载均衡策略：轮训、随机和根据响应时间加权重 4. Ribbon在cloud-client新版中被继承。 LoadBalancer 这个也可以用但是出来的时间不长 服务调用2 Feign 不要用了 Feign是一个声明式的Web服务客户端，说白了就是一个微服务接口与java声明式接口绑定的工具 一个接口被多次调用，所以通常都会针对每个微服务自行分装一些客户端类来包装这些依赖服务的调用。所以feign的实现下，我们只需要创建一个接口并使用注解的方式配置大就可以完成对服务方的接口绑定。 Feign内置了Ribbon。使用Feign定义的注解，调用这个接口就能调动注册中心的服务 用在消费方 OpenFeign 社区提供的Feign 是在Feign的基础之上支持了SpringMVC的注解，然后通过动态代理的方式产生实现类，实现类中做负载均衡并调动服务 OpenFeign的实现：微服务调用接口+@FeignClient 第一步在需要调用的springboot启动类中添加@EnableFeignClients，然后在service接口中添加@Component和@FeignClient(value = “PAYMENT-SERVER”) 其中value是微服务的名字。方法上使用@GetMappingspringMVC的注解，这样就可以使用service中调用了。 消费者调用服务方的服务时候是通过网络服务所以需要考虑链接超时问题。其中OpenFeign默认超时是1秒钟，如果调用的服务接口1秒钟没有返回就会超时报错。如果想要定制这个1秒钟的超时为其他的话就需要在yml中修改配置。以为OpenFeign底层使用的是ribbon来实现负载均衡的所有这个超时配置修改，是修改的是ribbon的超时间配置。在yml中添加ribbon:ReadtimeOut：5000 ConnectTimeOut：5000 OpenFeign提供了日志打印功能，可以答应feign请求http的详细情况。日志级别是可以设置的有四种NONE默认不打印日志；BASIC:仅记录请求方法、URL、响应状态码以及执行时间；HEADERS。除了BASIC中定义的信息外还有请求的响应的头信息；FULL:除了HEADERS中定义的信息，还有请求和响应的正文以及元数据。 服务降级 Hystrix 不再用了，停止更新了 问题出现的场景：微服务越来越多，微服务的依赖也越来越多。如果在调用链路上的一个或者多个节点出现问题之后，该如何保证服务的正常运行，这个Hystrix框架就是用来解决这种情况的。 一、定义： ​ Hystrix是一个分布式系统的延迟和容错的开源库。在两路中一个依赖出现问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性 二、能够处理问题的方法：服务熔断和服务降级以及接近实时的监控、限流、隔离 三、第“二”条中的概念 服务降级（fallback） 如果调用的服务出现异常，向调用方返回一个符合预期的可处理的备选响应（Fallback） 哪些情况会触发降级呢？ 程序运行异常 请求超时异常 服务熔断触发服务降级 线程池或者信号量打满也会导致服务降级 服务熔断（break） 先将服务断掉，然后调用服务降级的方法并返回友好提示 处理过程：服务的降级-&amp;gt;进而熔断-&amp;gt;恢复调用链路 服务限流（flowlimit） 如果对于一个服务来说如果一个高并发过来流量拥挤，然后就让这个大流量排队，按照服务能够处理的能力来排队处理 四、产生服务降级的问题，以及如何解决下边三个维度 超时导致服务器变慢-》超时不再等待 出错（调用服务宕机或者程序运行出错）-》要有兜底的逻辑 如果对方服务是ok的但是业务要求调用方需要被调用的服务在有效时间内给出答案如果不行的话需要服务降级处理 五、服务降级的配置 可以使用注解也可以使用类继承，这里直接说注解的使用@HystrixCommand。在微服务的启动类上添加该注解。 https://www.bilibili.com/video/BV18E411x7eT?p=54 降级有两种一种是自己对自己的降级，就是监控自己的一个方法，如果方法报错的话要有一个兜底的处理方法（服务端降级保护）。另外一种就是如果调用其他微服务的时候报错，那么对返回的错误或者等不到的时候就做其他兜底方法处理（客户端降级保护） 自定义和全局的降级处理，在接口类上边直接用一个@defaultProperties 然后定义一个defaultFallback方法。 还可以使用@feiClint中的defaultFallBack类，指定一个实现了interface类，让指定的实现的interface的类，然后重载实现所有方法，并写去处理逻辑 六、服务熔断 先关闭服务然后返回提示 断路器 open closed half-open 请求次数是否达到了峰值 涉及到断路器的三个重要参数：快照时间窗、请求总数阈值、错误百分比 断路器关闭的条件： 当满足一定的阈值的时候 当失败率达到一定的时候 达到以上法制断路器将会开启 当开启的时候所有请求都不会进行转发 一段时间之后这个时候断路器是搬开状态会让其中一个请求进行转发如果陈宫断路器会关闭如失败，继续开启重复4和5 工作流程需要总结 七、服务限流 在sentinel进行讲解 服务雪崩问题 “扇出”结构：说的就是多个微服务之间的调用，如果微服务A调用B，B有调用C，C和B有调用其他微服务 如果扇出来的链路上某个微服务的调用时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃。这个现象叫做雪崩效应 对于高流量应用来说，单一的后端依赖可能会导致所有服务器上的资源都在几秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或者系统。 通常当你法相一个模块下的某个实力失败后，这时候这个模块一样还会接受流量，然后这个有问题的模块还调用了其他模块，这样就发生级联故障，或者叫雪崩。 Hystrix是一个处理分布式系统延迟和容错的开元库，在分布式系统里，许多依赖不可避免的会调用失败，比如超市、异常等，Hystrix能够保证在一个依赖出现问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。 Hystrix就是一个“断路器”，当某个服务单元发生故障之后，通过断路器的故障监控，向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者跑出调用方无法处理的异常，这样就保证了调用方的线程不会备长时间、不必要的张勇虫儿避免了故障在分布式系统中的蔓延，乃至雪崩。 4. resilience4j 国外推荐使用 Sentinel 国内推荐，阿里巴巴 服务网关 Zuul 不再维护 1. gateway spring自己出的 异步非阻塞模型 getway具有如下特点： 基于spring framkework5，project reactor，spring boot2.0 构建的 动态路由：能够匹配任何请求属性 可以对路由指定断言和过滤器 集成Hystrix的断路器功能 集成spring cloud 服务发现功能 易于编写的断言和filter 请求限流功能 支持路径重写 spring cloud的Finchley正式版本之前都推荐Zuul Zuul1.x使用的是一个基于阻塞I/O的API 网关 2. 一、gateway 基于webflux框架实现 webflux使用的netty 目标提供统一的路由方式且基于Filter链的方式提供了网关基本功能 有什么功能： 反向代理 鉴权 流量控制 熔断 日志监控 特性 动态路由 可以对路由指定断言和过滤器 继承Hystrix的断路器功能 继承String cloud服务发现功能 已与编写的断言和过滤器 请求限流功能 支持路径重写 三个重要的部分： Route路由 Predicate断言 Filter过滤器 路由映射 1. 网关也是一个微服务 如何进行路由配置 使用yml进行配置 如果yml配置太多可以使用硬编码配置使用bean https://www.bilibili.com/video/BV18E411x7eT?p=70&amp;amp;spm_id_from=pageDriver 服务配置 config 现在不再使用了 可以使用Nacos 服务总线 Bus 现在不用了 携程还有一个appllo也用起来不错 可以使用Nacos 微服务问题 CAP问题 CAP定理： 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。 可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求 4. qps(每秒访问量) 2. Seata 服务 shardingsphere https://www.infoq.cn/article/w6wkhscktpa3-qmqi4gr</summary></entry><entry><title type="html">Spring</title><link href="/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring.html" rel="alternate" type="text/html" title="Spring" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring</id><content type="html" xml:base="/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring.html">&lt;h1 id=&quot;spring源码&quot;&gt;Spring源码&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20210226150948363.png&quot; alt=&quot;image-20210226150948363&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1ioc&quot;&gt;1.IOC&lt;/h2&gt;

&lt;p&gt;存放对象的容器&lt;/p&gt;

&lt;p&gt;如何存储容器对象使用key-value结构&lt;/p&gt;

&lt;p&gt;对象是谁创建？容器&lt;/p&gt;

&lt;p&gt;对象如何创建？new 工厂 反射的方式&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;xml与注解只要是为了解决bean定义信息（beandefine）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象默认是单例，可以配置成非单例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;名词：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;bean定义信息（BeanDefinition），一个spring的概念&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取器（BeanDefinitionReader），一个spring的概念，读取BeanDefinition放到容器中去&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bean工厂（BeanFactory）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象的创建的两个概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实例化：最主要的是在堆中开启一块空间，属性有默认值&lt;/li&gt;
  &lt;li&gt;初始化：
    &lt;ul&gt;
      &lt;li&gt;属性赋值&lt;/li&gt;
      &lt;li&gt;初始化方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实例化之后要初始化，才会生成一个完整的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;postprocessor 后置处理器（增强器）：多xml，没有xml都需要一个公有的值，&lt;/p&gt;

&lt;h1 id=&quot;spirng的启动过程&quot;&gt;Spirng的启动过程&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;obtainFreshBeanFactory()创建BeanFactory(ConfigurableListableBeanFactory类型的对象)
    &lt;ol&gt;
      &lt;li&gt;loadBeanDefinitions()方法创建 reader&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;往BeanFactory中添加东西使用prepareBeanFactory()配置 ClassLoader and post-processors&lt;/li&gt;
  &lt;li&gt;其中invokeBeanFactoryPostProcessors方法是对上边prepareBeanFactory()方法中注入的对象进行处理。这个时候就完成了BeanFactoryPostProcessor过程&lt;/li&gt;
  &lt;li&gt;国际话的一些操作initMessageSource();&lt;/li&gt;
  &lt;li&gt;子类实现来执行这个方法onRefresh();比如springboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;bean的生命周期&quot;&gt;Bean的生命周期&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;实现一堆Aware接口（但实现某个Aware接口之后，就意味着可以通过当前bean对象很方便的获取到容器中存在的对象）&lt;/li&gt;
  &lt;li&gt;执行BeanPostProcessor的before方法&lt;/li&gt;
  &lt;li&gt;执行当前对象定义的init方法&lt;/li&gt;
  &lt;li&gt;实例化&lt;/li&gt;
  &lt;li&gt;执行BeanPostProcessor的after方法&lt;/li&gt;
  &lt;li&gt;调用DisposeableBean方法 bean销毁方法&lt;/li&gt;
  &lt;li&gt;调用destory方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;销毁的话是在容器关闭，用户是不能直接销毁对象的&lt;/p&gt;

&lt;h1 id=&quot;6个主要的接口&quot;&gt;6个主要的接口&lt;/h1&gt;

&lt;h2 id=&quot;1beanfactory&quot;&gt;1.BeanFactory&lt;/h2&gt;

&lt;p&gt;The root interface for accessing a Spring bean container.&lt;/p&gt;

&lt;p&gt;用于访问Spring bean容器的根接口&lt;/p&gt;

&lt;p&gt;This is the basic client view of a bean container;&lt;/p&gt;

&lt;p&gt;这是bean容器的基本客户端视图&lt;/p&gt;

&lt;p&gt;further interfaces such as ListableBeanFactory and org.springframework.beans.factory.config.ConfigurableBeanFactory are available for specific purposes.&lt;/p&gt;

&lt;p&gt;还有其他接口，例如{@link ListableBeanFactory}和{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}可用于特定目的。&lt;/p&gt;

&lt;p&gt;This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. “request” and “session” scopes in a web environment).&lt;/p&gt;

&lt;p&gt;该接口由包含多个bean定义的对象实现，每个定义均由String名称唯一标识。根据bean的定义，工厂将返回一个包含对象的独立实例（Prototype设计模式），或者返回一个共享实例（Singleton设计模式的替代方案，其中实例是作用域中的单例）。的工厂）。将返回哪种类型的实例取决于bean工厂的配置：API是相同的。从Spring 2.0开始，取决于具体的应用程序上下文，可以使用更多范围（例如，网络环境中的“ request”和“ session”范围）。&lt;/p&gt;

&lt;p&gt;The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of “Expert One-on-One J2EE Design and Development” for a discussion of the benefits of this approach.&lt;/p&gt;

&lt;p&gt;此方法的重点是BeanFactory是应用程序组件的中央注册表，并集中了应用程序组件的配置（例如，单个对象不再需要读取属性文件）。有关此方法的好处的讨论，请参见“一对一J2EE专家设计和开发”的第4章和第11章。&lt;/p&gt;

&lt;p&gt;Note that it is generally better to rely on Dependency Injection (“push” configuration) to configure application objects through setters or constructors, rather than use any form of “pull” configuration like a BeanFactory lookup. Spring’s Dependency Injection functionality is implemented using this BeanFactory interface and its subinterfaces.&lt;/p&gt;

&lt;p&gt;请注意，通常最好依赖于依赖注入（“ push”配置）通过设置器或构造函数配置应用程序对象，而不是使用任何形式的“ pull”配置（例如BeanFactory查找）。 Spring的Dependency Injection功能是使用此BeanFactory接口及其子接口实现的。&lt;/p&gt;

&lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection).&lt;/p&gt;

&lt;p&gt;通常，BeanFactory会加载存储在配置源（例如XML文档）中的Bean定义，并使用{@code org.springframework.beans}包来配置Bean。但是，实现可以根据需要直接在Java代码中直接返回它创建的Java对象。定义的存储方式没有任何限制：LDAP，RDBMS，XML，属性文件等。鼓励实现以支持Bean之间的引用（Dependency Injection）。&lt;/p&gt;

&lt;p&gt;In contrast to the methods in ListableBeanFactory, all of the operations in this interface will also check parent factories if this is a HierarchicalBeanFactory. If a bean is not found in this factory instance, the immediate parent factory will be asked. Beans in this factory instance are supposed to override beans of the same name in any parent factory.&lt;/p&gt;

&lt;p&gt;与{@link ListableBeanFactory}中的方法相比，此接口中的所有操作还将检查父工厂是否为{@link HierarchicalBeanFactory}。如果在此工厂实例中未找到bean，则将询问直接的父工厂。该工厂实例中的Bean应该覆盖任何父工厂中同名的Bean。&lt;/p&gt;

&lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:&lt;/p&gt;

&lt;p&gt;Bean工厂实现应尽可能支持标准Bean生命周期接口。全套初始化方法及其标准顺序为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanNameAware’s setBeanName&lt;/li&gt;
  &lt;li&gt;BeanClassLoaderAware’s setBeanClassLoader&lt;/li&gt;
  &lt;li&gt;BeanFactoryAware’s setBeanFactory&lt;/li&gt;
  &lt;li&gt;EnvironmentAware’s setEnvironment&lt;/li&gt;
  &lt;li&gt;EmbeddedValueResolverAware’s setEmbeddedValueResolver&lt;/li&gt;
  &lt;li&gt;ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ApplicationEventPublisherAware’s setApplicationEventPublisher (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;MessageSourceAware’s setMessageSource (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ApplicationContextAware’s setApplicationContext (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ServletContextAware’s setServletContext (only applicable when running in a web application context)&lt;/li&gt;
  &lt;li&gt;postProcessBeforeInitialization methods of BeanPostProcessors&lt;/li&gt;
  &lt;li&gt;InitializingBean’s afterPropertiesSet&lt;/li&gt;
  &lt;li&gt;a custom init-method definition&lt;/li&gt;
  &lt;li&gt;postProcessAfterInitialization methods of BeanPostProcessors&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;/p&gt;

&lt;p&gt;在关闭bean工厂的过程中，以下生命周期方法适用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors&lt;/li&gt;
  &lt;li&gt;DisposableBean’s destroy&lt;/li&gt;
  &lt;li&gt;a custom destroy-method definition&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2beanpostprocessor&quot;&gt;2.BeanPostProcessor&lt;/h2&gt;

&lt;p&gt;Factory hook that allows for custom modification of new bean instances — for example, checking for marker interfaces or wrapping beans with proxies.&lt;/p&gt;

&lt;p&gt;工厂挂钩允许对新bean实例进行自定义修改-例如，检查标记接口或使用代理包装bean。&lt;/p&gt;

&lt;p&gt;Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.&lt;/p&gt;

&lt;p&gt;通常，通过标记接口等填充bean的后处理器将实现postProcessBeforeInitialization，而使用代理包装bean的后处理器通常将实现postProcessAfterInitialization。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Registration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;登记注册&lt;/p&gt;

&lt;p&gt;An ApplicationContext can autodetect BeanPostProcessor beans in its bean definitions and apply those post-processors to any beans subsequently created. A plain BeanFactory allows for programmatic registration of post-processors, applying them to all beans created through the bean factory.&lt;/p&gt;

&lt;p&gt;{@code ApplicationContext}可以在其bean定义中自动检测{@code BeanPostProcessor} bean，并将这些后处理器应用于随后创建的任何bean。普通的{@code BeanFactory}允许以编程方式注册&lt;/p&gt;

&lt;p&gt;Ordering&lt;/p&gt;

&lt;p&gt;排序&lt;/p&gt;

&lt;p&gt;BeanPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanPostProcessor beans that are registered programmatically with a BeanFactory will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanPostProcessor beans.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中自动检测到的{@code BeanPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code BeanFactory}以编程方式注册的{@code BeanPostProcessor} bean；以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。&lt;/p&gt;

&lt;h2 id=&quot;3environment&quot;&gt;3.Environment&lt;/h2&gt;

&lt;p&gt;Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.&lt;/p&gt;

&lt;p&gt;表示当前应用程序正在其中运行的环境的接口。为应用程序环境的两个关键方面建模：&lt;em&gt; profiles &lt;em&gt;和&lt;em&gt; properties &lt;em&gt;。与属性访问有关的方法是通过{@link PropertyResolver}超级接口公开的。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the @Profile annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;配置文件&lt;em&gt;是命名的逻辑定义的Bean定义组，仅当给定的配置文件为&lt;em&gt; active &lt;em&gt;时才向容器注册。可以将Bean分配给概要文件，无论是XML定义还是通过注释定义。有关语法的详细信息，请参见spring-beans 3.1模式或{@link org.springframework.context.annotation.Profile @Profile}批注。 {@code Environment}对象与配置文件相关的作用是确定哪些配置文件（如果有的话）当前{@linkplain getActiveProfiles有效}，以及哪些配置文件（如果有的话）应为{@linkplain getDefaultProfiles默认为活动状态}。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt; Properties &lt;em&gt;在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，地图，等等。环境对象与属性有关的作用是为用户提供方便的服务界面，用于配置属性源并从中解析属性。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Beans managed within an ApplicationContext may register to be EnvironmentAware or @Inject the Environment in order to query profile state or resolve properties directly.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中管理的Bean可以注册为{@link org.springframework.context.EnvironmentAware EnvironmentAware}或{@code @Inject} {@code Environment}，以便查询概要文件状态或直接解析属性。&lt;/p&gt;

&lt;p&gt;In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using &lt;context:property-placeholder&gt;&lt;/context:property-placeholder&gt;.&lt;/p&gt;

&lt;p&gt;但是，在大多数情况下，应用程序级Bean无需直接与{@code Environment}进行交互，而可能必须将{@code {…}}属性值替换为诸如{@链接org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer}本身就是{@code EnvironmentAware}，从Spring 3.1开始，默认情况下使用{@code &amp;lt;context：property-placeholder&amp;gt;}注册。&lt;/p&gt;

&lt;p&gt;Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh().&lt;/p&gt;

&lt;p&gt;必须通过从所有{@code AbstractApplicationContext}子类{@code getEnvironment（）}方法返回的{@code ConfigurableEnvironment}接口完成环境对象的配置。请参阅{@link ConfigurableEnvironment} Javadoc以获取使用示例，这些示例演示了在应用程序上下文{@code refresh（）}之前对属性源进行的操作。&lt;/p&gt;

&lt;h2 id=&quot;4factorybean&quot;&gt;4.FactoryBean&lt;/h2&gt;

&lt;p&gt;Interface to be implemented by objects used within a BeanFactory which are themselves factories for individual objects. If a bean implements this interface, it is used as a factory for an object to expose, not directly as a bean instance that will be exposed itself.&lt;/p&gt;

&lt;p&gt;由{@link BeanFactory}中使用的对象实现的接口，这些对象本身就是单个对象的工厂。如果bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。&lt;/p&gt;

&lt;p&gt;NB: A bean that implements this interface cannot be used as a normal bean. A FactoryBean is defined in a bean style, but the object exposed for bean references (getObject()) is always the object that it creates.&lt;/p&gt;

&lt;p&gt;注意：实现此接口的bean不能用作普通bean。&lt;b&gt;  FactoryBean是用bean样式定义的，但是为bean引用公开的对象（getObject（）)始终是它创建的对象。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create objects lazily on demand or eagerly on startup. The SmartFactoryBean interface allows for exposing more fine-grained behavioral metadata.&lt;/p&gt;

&lt;p&gt;FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 {@link SmartFactoryBean}接口允许公开更细粒度的行为元数据&lt;/p&gt;

&lt;p&gt;This interface is heavily used within the framework itself, for example for the AOP org.springframework.aop.framework.ProxyFactoryBean or the org.springframework.jndi.JndiObjectFactoryBean. It can be used for custom components as well; however, this is only common for infrastructure code.&lt;/p&gt;

&lt;p&gt;此接口在框架本身中大量使用，例如用于AOP {@link org.springframework.aop.framework.ProxyFactoryBean}或{@link org.springframework.jndi.JndiObjectFactoryBean}。它也可以用于自定义组件。但是，这仅在基础结构代码中很常见。&lt;/p&gt;

&lt;p&gt;FactoryBean is a programmatic contract. Implementations are not supposed to rely on annotation-driven injection or other reflective facilities. getObjectType() getObject() invocations may arrive early in the bootstrap process, even ahead of any post-processor setup. If you need access to other beans, implement BeanFactoryAware and obtain them programmatically.&lt;/p&gt;

&lt;p&gt;{@code FactoryBean}是程序性合同。实现不应依赖于注释驱动的注入或其他反射性工具。&lt;b&gt; {@link getObjectType（）} {@link getObject（）}调用可能会在引导过程的早期到达，即使在任何后处理器设置之前也是如此。 。如果需要访问其他bean，请实现{@link BeanFactoryAware}并以编程方式获取它们。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;The container is only responsible for managing the lifecycle of the FactoryBean instance, not the lifecycle of the objects created by the FactoryBean. Therefore, a destroy method on an exposed bean object (such as java.io.Closeable.close() will not be called automatically. Instead, a FactoryBean should implement DisposableBean and delegate any such close call to the underlying object.&lt;/p&gt;

&lt;p&gt;容器仅负责管理FactoryBean实例的生命周期，而不负责管理FactoryBean创建的对象的生命周期。因此，在暴露的bean对象上的destroy方法(例如{@link java.io.Closeableclose（）)将&lt;i&gt;不&lt;i&gt;被自动调用。&lt;/i&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory’s synchronization of bean creation. There is usually no need for internal synchronization other than for purposes of lazy initialization within the FactoryBean itself (or the like).&lt;/p&gt;

&lt;p&gt;最后，FactoryBean对象参与包含BeanFactory的Bean创建同步。除了出于FactoryBean自身（或类似方式）内部的延迟初始化的目的之外，通常不需要内部同步。&lt;/p&gt;

&lt;h2 id=&quot;5beanfactorypostprocessor&quot;&gt;5.BeanFactoryPostProcessor&lt;/h2&gt;

&lt;p&gt;Factory hook that allows for custom modification of an application context’s bean definitions, adapting the bean property values of the context’s underlying bean factory.&lt;/p&gt;

&lt;p&gt;工厂挂钩允许对应用程序上下文的Bean定义进行自定义修改，以适应上下文基础Bean工厂的Bean属性值。&lt;/p&gt;

&lt;p&gt;Useful for custom config files targeted at system administrators that override bean properties configured in the application context. See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.&lt;/p&gt;

&lt;p&gt;对于针对系统管理员的自定义配置文件很有用，这些文件覆盖了在应用程序上下文中配置的Bean属性。请参阅{@link PropertyResourceConfigurer}及其具体实现，以了解解决此类配置需求的即用型解决方案。&lt;/p&gt;

&lt;p&gt;A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.&lt;/p&gt;

&lt;p&gt;{@code BeanFactoryPostProcessor}可以与Bean定义进行交互并对其进行修改，但不能与Bean实例进行交互。这样做可能会导致bean实例化过早，从而违反了容器并造成了意想不到的副作用。如果需要bean实例交互，请考虑改为实现{@link BeanPostProcessor}。&lt;/p&gt;

&lt;p&gt;Registration
An ApplicationContext auto-detects BeanFactoryPostProcessor beans in its bean definitions and applies them before any other beans get created. A BeanFactoryPostProcessor may also be registered programmatically with a ConfigurableApplicationContext.&lt;/p&gt;

&lt;p&gt;{@code ApplicationContext}在其bean定义中自动检测{@code BeanFactoryPostProcessor} bean，并在创建任何其他bean之前应用它们。 {@code BeanFactoryPostProcessor}也可以通过编程方式向{@code ConfigurableApplicationContext}注册&lt;/p&gt;

&lt;p&gt;Ordering
BeanFactoryPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanFactoryPostProcessor beans that are registered programmatically with a ConfigurableApplicationContext will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanFactoryPostProcessor beans.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中自动检测到的{@code BeanFactoryPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code ConfigurableApplicationContext}以编程方式注册的{@code BeanFactoryPostProcessor} bean。以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanFactoryPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。&lt;/p&gt;

&lt;h2 id=&quot;6beandefinitionreader&quot;&gt;6.BeanDefinitionReader&lt;/h2&gt;

&lt;p&gt;Simple interface for bean definition readers.&lt;/p&gt;

&lt;p&gt;Bean定义阅读器的简单界面。&lt;/p&gt;

&lt;p&gt;Specifies load methods with Resource and String location parameters.&lt;/p&gt;

&lt;p&gt;指定带有“资源”和“字符串”位置参数的加载方法。&lt;/p&gt;

&lt;p&gt;Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format.&lt;/p&gt;

&lt;p&gt;当然，具体的bean定义阅读器可以为bean定义添加特定于其bean定义格式的附加加载和注册方法。&lt;/p&gt;

&lt;p&gt;Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions.&lt;/p&gt;

&lt;p&gt;注意，bean定义阅读器不必实现此接口。它仅对希望遵循标准命名约定的Bean定义读者提供建议。&lt;/p&gt;

&lt;h1 id=&quot;循环依赖的问题&quot;&gt;循环依赖的问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;什么是循环依赖&lt;/li&gt;
  &lt;li&gt;spring中如何解决循环依赖问题&lt;/li&gt;
  &lt;li&gt;为什么要使用三级缓存解决循环依赖问题？一级缓存行不行？二级缓存行不行？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;解答循环依赖&quot;&gt;解答循环依赖&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;基本逻辑:如果使用构造器的方法创建对象的时候必须创建依赖的其他类型对象，可以使用无参构造器创建对象然后使用set方法注入依赖的bean对象。&lt;/li&gt;
  &lt;li&gt;解决依赖的主要类DefaultSingletonBeanRegistry
    &lt;ol&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下边所说的前提：创建的所有对象都是单例对象&lt;/p&gt;

&lt;p&gt;循环依赖问题：&lt;/p&gt;

&lt;p&gt;如果是构造器方式没有办法解决&lt;/p&gt;

&lt;p&gt;如果是setter方式可以使用三级缓存方式解决&lt;/p&gt;

&lt;p&gt;三级缓存就是三个map，区别是在他们的value类型&lt;/p&gt;

&lt;p&gt;其中三级缓存singletonFactories&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;cm&quot;&gt;/**
	 * Return an instance (possibly shared or independent)
	 * of the object managed by this factory.
	 * @return the resulting instance
	 * @throws BeansException in case of creation errors
	 */&lt;/span&gt;
	&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际执行匿名内部类&lt;/p&gt;

&lt;p&gt;提前暴露对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/Users/haining/Library/Application Support/typora-user-images/image-20210311202715679.png&quot; alt=&quot;image-20210311202715679&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会有两个lambda表达式参数传递&lt;/p&gt;

&lt;p&gt;RuntimeBeanReference 运行时的应用&lt;/p&gt;

&lt;p&gt;从一级缓存 二级缓存 三级缓存&lt;/p&gt;

&lt;h3 id=&quot;为什么非要用三级缓存二级缓存行不行以及行不行&quot;&gt;为什么非要用三级缓存？二级缓存行不行？以及行不行？&lt;/h3&gt;

&lt;p&gt;一级缓存中会放置完整的对象或者非完整对象，如果在操作的时候恰巧获取到非完全对象怎么办？&lt;/p&gt;

&lt;p&gt;一级缓存放完整对象，二级缓存放非完整对象，&lt;/p&gt;

&lt;h3 id=&quot;在创建代理对象的时候需不需要提前创建出属性是默认值的普通对象&quot;&gt;在创建代理对象的时候，需不需要提前创建出属性是默认值的普通对象？&lt;/h3&gt;

&lt;p&gt;一定会创建出普通对象&lt;/p&gt;

&lt;p&gt;当需要创建代理对象的时候，需要执行一个lambda表达式来创建代理类，如果没有三级缓存的话，就有可能有一种情况，刚开始县创建出普通对象，然后被调用了，后续又需要代理对象，此时生成，那么最终使用的效果是有些使用普通对象有些使用代理对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果没有aop的实现的话，二级缓存就可以了。三级缓存可以解决aop的代理类问题&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;6aop的底层实现&quot;&gt;6.AOP的底层实现&lt;/h2&gt;

&lt;h1 id=&quot;refresh方法的实现&quot;&gt;refresh方法的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/p&gt;

    &lt;p&gt;做了两件事情:读取xml文件(获取非xml的其他的文件或者注解的配置)中的配置;创建BeanFactory&lt;/p&gt;

    &lt;p&gt;过程：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;首先调用refreshBeanFactory();检测是否已经有beanFactory如果有就销毁beanFactory，然后就使用DefaultListableBeanFactory beanFactory = createBeanFactory();创建BeanFactory是DefaultListableBeanFactory对象。这个对象就是&lt;strong&gt;容器&lt;/strong&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;然后就是给beanFactory对象添加个性化定制的参数customizeBeanFactory(beanFactory);&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;接下来是重点loadBeanDefinitions(beanFactory);这个方法主要是加载xml或者其他方式写的bean定义的配置数据。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;先创建一个BeanDefinitionReader对象&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;设置一些配置&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setResourceLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEntityResolver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResourceEntityResolver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//this 是指ApplicationContext对象&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;然后使用loadBeanDefinitions(beanDefinitionReader)方法加载bean信息。&lt;/p&gt;

            &lt;p&gt;通过String[] configLocations = getConfigLocations()获取bean的配置，如果是xml文件的话就是XML文件名字。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;然后处理加载出来的bean的配置的信息。&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//以下方法，依次在方法体内调用下一个方法&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actualResources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;EncodedResource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encodedResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;其中int loadBeanDefinitions(EncodedResource encodedResource)这个方法中会将encodedResource的IO流获取到然后调用doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法来加载配置信息。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;介绍doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法&lt;/p&gt;

            &lt;p&gt;我做实现用的xml文件来配置bean。所以这个地方就是从xml中获取bean信息的。Document doc = doLoadDocument(inputSource, resource)就是获取document对象然后交给registerBeanDefinitions(doc, resource)方法做加载最后存放在XmlBeanDefinitionReader中的中的属性BeanFactory的beanDefinitionMap中这个map是bean的名字和BeanDefinition对象。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法prepareBeanFactory(beanFactory);&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Spel表达式处理组件加载beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));&lt;/li&gt;
      &lt;li&gt;Bean修改组件加载beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));&lt;/li&gt;
      &lt;li&gt;BeanPostProcessor加载beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法invokeBeanFactoryPostProcessors(beanFactory)这个方法就是处理上几步注册的BeanFactoryPostProcessor的，&lt;strong&gt;这个地方可以扩展，自定义一个BeanFactoryPostProcessor（自定义的类可以实现void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;方法，这个方法还能获取到beanFactory，并做修改或者是一些其他的操作。&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关键代码PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());中的PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法的实现
        &lt;ol&gt;
          &lt;li&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法registerBeanPostProcessors(beanFactory);这个方法是加载BeanPostProcessor的。处理逻辑大致与invokeBeanFactoryPostProcessors处理BeanFactoryPostProcessor的获取processor对象逻辑基本一致，获取之后就加载到beanFactory中然后在初始化bean的时候才会执行这些方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>tyning.another</name></author><category term="Spring" /><category term="源码" /><category term="Spring" /><summary type="html">Spring源码 1.IOC 存放对象的容器 如何存储容器对象使用key-value结构 对象是谁创建？容器 对象如何创建？new 工厂 反射的方式 Class clazz = Person.class; Constructor ctor = clazz.getConstructor(); Object person = ctor.newInstance(); xml与注解只要是为了解决bean定义信息（beandefine） 对象默认是单例，可以配置成非单例 名词： bean定义信息（BeanDefinition），一个spring的概念 读取器（BeanDefinitionReader），一个spring的概念，读取BeanDefinition放到容器中去 bean工厂（BeanFactory） 对象的创建的两个概念： 实例化：最主要的是在堆中开启一块空间，属性有默认值 初始化： 属性赋值 初始化方法 实例化之后要初始化，才会生成一个完整的对象 postprocessor 后置处理器（增强器）：多xml，没有xml都需要一个公有的值， Spirng的启动过程 obtainFreshBeanFactory()创建BeanFactory(ConfigurableListableBeanFactory类型的对象) loadBeanDefinitions()方法创建 reader 往BeanFactory中添加东西使用prepareBeanFactory()配置 ClassLoader and post-processors 其中invokeBeanFactoryPostProcessors方法是对上边prepareBeanFactory()方法中注入的对象进行处理。这个时候就完成了BeanFactoryPostProcessor过程 国际话的一些操作initMessageSource(); 子类实现来执行这个方法onRefresh();比如springboot Bean的生命周期 实现一堆Aware接口（但实现某个Aware接口之后，就意味着可以通过当前bean对象很方便的获取到容器中存在的对象） 执行BeanPostProcessor的before方法 执行当前对象定义的init方法 实例化 执行BeanPostProcessor的after方法 调用DisposeableBean方法 bean销毁方法 调用destory方法 销毁的话是在容器关闭，用户是不能直接销毁对象的 6个主要的接口 1.BeanFactory The root interface for accessing a Spring bean container. 用于访问Spring bean容器的根接口 This is the basic client view of a bean container; 这是bean容器的基本客户端视图 further interfaces such as ListableBeanFactory and org.springframework.beans.factory.config.ConfigurableBeanFactory are available for specific purposes. 还有其他接口，例如{@link ListableBeanFactory}和{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}可用于特定目的。 This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. “request” and “session” scopes in a web environment). 该接口由包含多个bean定义的对象实现，每个定义均由String名称唯一标识。根据bean的定义，工厂将返回一个包含对象的独立实例（Prototype设计模式），或者返回一个共享实例（Singleton设计模式的替代方案，其中实例是作用域中的单例）。的工厂）。将返回哪种类型的实例取决于bean工厂的配置：API是相同的。从Spring 2.0开始，取决于具体的应用程序上下文，可以使用更多范围（例如，网络环境中的“ request”和“ session”范围）。 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of “Expert One-on-One J2EE Design and Development” for a discussion of the benefits of this approach. 此方法的重点是BeanFactory是应用程序组件的中央注册表，并集中了应用程序组件的配置（例如，单个对象不再需要读取属性文件）。有关此方法的好处的讨论，请参见“一对一J2EE专家设计和开发”的第4章和第11章。 Note that it is generally better to rely on Dependency Injection (“push” configuration) to configure application objects through setters or constructors, rather than use any form of “pull” configuration like a BeanFactory lookup. Spring’s Dependency Injection functionality is implemented using this BeanFactory interface and its subinterfaces. 请注意，通常最好依赖于依赖注入（“ push”配置）通过设置器或构造函数配置应用程序对象，而不是使用任何形式的“ pull”配置（例如BeanFactory查找）。 Spring的Dependency Injection功能是使用此BeanFactory接口及其子接口实现的。 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). 通常，BeanFactory会加载存储在配置源（例如XML文档）中的Bean定义，并使用{@code org.springframework.beans}包来配置Bean。但是，实现可以根据需要直接在Java代码中直接返回它创建的Java对象。定义的存储方式没有任何限制：LDAP，RDBMS，XML，属性文件等。鼓励实现以支持Bean之间的引用（Dependency Injection）。 In contrast to the methods in ListableBeanFactory, all of the operations in this interface will also check parent factories if this is a HierarchicalBeanFactory. If a bean is not found in this factory instance, the immediate parent factory will be asked. Beans in this factory instance are supposed to override beans of the same name in any parent factory. 与{@link ListableBeanFactory}中的方法相比，此接口中的所有操作还将检查父工厂是否为{@link HierarchicalBeanFactory}。如果在此工厂实例中未找到bean，则将询问直接的父工厂。该工厂实例中的Bean应该覆盖任何父工厂中同名的Bean。 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is: Bean工厂实现应尽可能支持标准Bean生命周期接口。全套初始化方法及其标准顺序为： BeanNameAware’s setBeanName BeanClassLoaderAware’s setBeanClassLoader BeanFactoryAware’s setBeanFactory EnvironmentAware’s setEnvironment EmbeddedValueResolverAware’s setEmbeddedValueResolver ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context) ApplicationEventPublisherAware’s setApplicationEventPublisher (only applicable when running in an application context) MessageSourceAware’s setMessageSource (only applicable when running in an application context) ApplicationContextAware’s setApplicationContext (only applicable when running in an application context) ServletContextAware’s setServletContext (only applicable when running in a web application context) postProcessBeforeInitialization methods of BeanPostProcessors InitializingBean’s afterPropertiesSet a custom init-method definition postProcessAfterInitialization methods of BeanPostProcessors On shutdown of a bean factory, the following lifecycle methods apply: 在关闭bean工厂的过程中，以下生命周期方法适用： postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors DisposableBean’s destroy a custom destroy-method definition 2.BeanPostProcessor Factory hook that allows for custom modification of new bean instances — for example, checking for marker interfaces or wrapping beans with proxies. 工厂挂钩允许对新bean实例进行自定义修改-例如，检查标记接口或使用代理包装bean。 Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization. 通常，通过标记接口等填充bean的后处理器将实现postProcessBeforeInitialization，而使用代理包装bean的后处理器通常将实现postProcessAfterInitialization。 Registration 登记注册 An ApplicationContext can autodetect BeanPostProcessor beans in its bean definitions and apply those post-processors to any beans subsequently created. A plain BeanFactory allows for programmatic registration of post-processors, applying them to all beans created through the bean factory. {@code ApplicationContext}可以在其bean定义中自动检测{@code BeanPostProcessor} bean，并将这些后处理器应用于随后创建的任何bean。普通的{@code BeanFactory}允许以编程方式注册 Ordering 排序 BeanPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanPostProcessor beans that are registered programmatically with a BeanFactory will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanPostProcessor beans. 在{@code ApplicationContext}中自动检测到的{@code BeanPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code BeanFactory}以编程方式注册的{@code BeanPostProcessor} bean；以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。 3.Environment Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface. 表示当前应用程序正在其中运行的环境的接口。为应用程序环境的两个关键方面建模： profiles 和 properties 。与属性访问有关的方法是通过{@link PropertyResolver}超级接口公开的。 A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the @Profile annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. 配置文件是命名的逻辑定义的Bean定义组，仅当给定的配置文件为 active 时才向容器注册。可以将Bean分配给概要文件，无论是XML定义还是通过注释定义。有关语法的详细信息，请参见spring-beans 3.1模式或{@link org.springframework.context.annotation.Profile @Profile}批注。 {@code Environment}对象与配置文件相关的作用是确定哪些配置文件（如果有的话）当前{@linkplain getActiveProfiles有效}，以及哪些配置文件（如果有的话）应为{@linkplain getDefaultProfiles默认为活动状态}。 Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them. Properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，地图，等等。环境对象与属性有关的作用是为用户提供方便的服务界面，用于配置属性源并从中解析属性。 Beans managed within an ApplicationContext may register to be EnvironmentAware or @Inject the Environment in order to query profile state or resolve properties directly. 在{@code ApplicationContext}中管理的Bean可以注册为{@link org.springframework.context.EnvironmentAware EnvironmentAware}或{@code @Inject} {@code Environment}，以便查询概要文件状态或直接解析属性。 In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using . 但是，在大多数情况下，应用程序级Bean无需直接与{@code Environment}进行交互，而可能必须将{@code {…}}属性值替换为诸如{@链接org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer}本身就是{@code EnvironmentAware}，从Spring 3.1开始，默认情况下使用{@code &amp;lt;context：property-placeholder&amp;gt;}注册。 Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh(). 必须通过从所有{@code AbstractApplicationContext}子类{@code getEnvironment（）}方法返回的{@code ConfigurableEnvironment}接口完成环境对象的配置。请参阅{@link ConfigurableEnvironment} Javadoc以获取使用示例，这些示例演示了在应用程序上下文{@code refresh（）}之前对属性源进行的操作。 4.FactoryBean Interface to be implemented by objects used within a BeanFactory which are themselves factories for individual objects. If a bean implements this interface, it is used as a factory for an object to expose, not directly as a bean instance that will be exposed itself. 由{@link BeanFactory}中使用的对象实现的接口，这些对象本身就是单个对象的工厂。如果bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。 NB: A bean that implements this interface cannot be used as a normal bean. A FactoryBean is defined in a bean style, but the object exposed for bean references (getObject()) is always the object that it creates. 注意：实现此接口的bean不能用作普通bean。 FactoryBean是用bean样式定义的，但是为bean引用公开的对象（getObject（）)始终是它创建的对象。 FactoryBeans can support singletons and prototypes, and can either create objects lazily on demand or eagerly on startup. The SmartFactoryBean interface allows for exposing more fine-grained behavioral metadata. FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 {@link SmartFactoryBean}接口允许公开更细粒度的行为元数据 This interface is heavily used within the framework itself, for example for the AOP org.springframework.aop.framework.ProxyFactoryBean or the org.springframework.jndi.JndiObjectFactoryBean. It can be used for custom components as well; however, this is only common for infrastructure code. 此接口在框架本身中大量使用，例如用于AOP {@link org.springframework.aop.framework.ProxyFactoryBean}或{@link org.springframework.jndi.JndiObjectFactoryBean}。它也可以用于自定义组件。但是，这仅在基础结构代码中很常见。 FactoryBean is a programmatic contract. Implementations are not supposed to rely on annotation-driven injection or other reflective facilities. getObjectType() getObject() invocations may arrive early in the bootstrap process, even ahead of any post-processor setup. If you need access to other beans, implement BeanFactoryAware and obtain them programmatically. {@code FactoryBean}是程序性合同。实现不应依赖于注释驱动的注入或其他反射性工具。 {@link getObjectType（）} {@link getObject（）}调用可能会在引导过程的早期到达，即使在任何后处理器设置之前也是如此。 。如果需要访问其他bean，请实现{@link BeanFactoryAware}并以编程方式获取它们。 The container is only responsible for managing the lifecycle of the FactoryBean instance, not the lifecycle of the objects created by the FactoryBean. Therefore, a destroy method on an exposed bean object (such as java.io.Closeable.close() will not be called automatically. Instead, a FactoryBean should implement DisposableBean and delegate any such close call to the underlying object. 容器仅负责管理FactoryBean实例的生命周期，而不负责管理FactoryBean创建的对象的生命周期。因此，在暴露的bean对象上的destroy方法(例如{@link java.io.Closeableclose（）)将不被自动调用。 Finally, FactoryBean objects participate in the containing BeanFactory’s synchronization of bean creation. There is usually no need for internal synchronization other than for purposes of lazy initialization within the FactoryBean itself (or the like). 最后，FactoryBean对象参与包含BeanFactory的Bean创建同步。除了出于FactoryBean自身（或类似方式）内部的延迟初始化的目的之外，通常不需要内部同步。 5.BeanFactoryPostProcessor Factory hook that allows for custom modification of an application context’s bean definitions, adapting the bean property values of the context’s underlying bean factory. 工厂挂钩允许对应用程序上下文的Bean定义进行自定义修改，以适应上下文基础Bean工厂的Bean属性值。 Useful for custom config files targeted at system administrators that override bean properties configured in the application context. See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs. 对于针对系统管理员的自定义配置文件很有用，这些文件覆盖了在应用程序上下文中配置的Bean属性。请参阅{@link PropertyResourceConfigurer}及其具体实现，以了解解决此类配置需求的即用型解决方案。 A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead. {@code BeanFactoryPostProcessor}可以与Bean定义进行交互并对其进行修改，但不能与Bean实例进行交互。这样做可能会导致bean实例化过早，从而违反了容器并造成了意想不到的副作用。如果需要bean实例交互，请考虑改为实现{@link BeanPostProcessor}。 Registration An ApplicationContext auto-detects BeanFactoryPostProcessor beans in its bean definitions and applies them before any other beans get created. A BeanFactoryPostProcessor may also be registered programmatically with a ConfigurableApplicationContext. {@code ApplicationContext}在其bean定义中自动检测{@code BeanFactoryPostProcessor} bean，并在创建任何其他bean之前应用它们。 {@code BeanFactoryPostProcessor}也可以通过编程方式向{@code ConfigurableApplicationContext}注册 Ordering BeanFactoryPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanFactoryPostProcessor beans that are registered programmatically with a ConfigurableApplicationContext will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanFactoryPostProcessor beans. 在{@code ApplicationContext}中自动检测到的{@code BeanFactoryPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code ConfigurableApplicationContext}以编程方式注册的{@code BeanFactoryPostProcessor} bean。以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanFactoryPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。 6.BeanDefinitionReader Simple interface for bean definition readers. Bean定义阅读器的简单界面。 Specifies load methods with Resource and String location parameters. 指定带有“资源”和“字符串”位置参数的加载方法。 Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format. 当然，具体的bean定义阅读器可以为bean定义添加特定于其bean定义格式的附加加载和注册方法。 Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions. 注意，bean定义阅读器不必实现此接口。它仅对希望遵循标准命名约定的Bean定义读者提供建议。 循环依赖的问题 什么是循环依赖 spring中如何解决循环依赖问题 为什么要使用三级缓存解决循环依赖问题？一级缓存行不行？二级缓存行不行？ 解答循环依赖 基本逻辑:如果使用构造器的方法创建对象的时候必须创建依赖的其他类型对象，可以使用无参构造器创建对象然后使用set方法注入依赖的bean对象。 解决依赖的主要类DefaultSingletonBeanRegistry 下边所说的前提：创建的所有对象都是单例对象 循环依赖问题： 如果是构造器方式没有办法解决 如果是setter方式可以使用三级缓存方式解决 三级缓存就是三个map，区别是在他们的value类型 其中三级缓存singletonFactories @FunctionalInterface public interface ObjectFactory&amp;lt;T&amp;gt; { /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return the resulting instance * @throws BeansException in case of creation errors */ T getObject() throws BeansException; } 实际执行匿名内部类 提前暴露对象 会有两个lambda表达式参数传递 RuntimeBeanReference 运行时的应用 从一级缓存 二级缓存 三级缓存 为什么非要用三级缓存？二级缓存行不行？以及行不行？ 一级缓存中会放置完整的对象或者非完整对象，如果在操作的时候恰巧获取到非完全对象怎么办？ 一级缓存放完整对象，二级缓存放非完整对象， 在创建代理对象的时候，需不需要提前创建出属性是默认值的普通对象？ 一定会创建出普通对象 当需要创建代理对象的时候，需要执行一个lambda表达式来创建代理类，如果没有三级缓存的话，就有可能有一种情况，刚开始县创建出普通对象，然后被调用了，后续又需要代理对象，此时生成，那么最终使用的效果是有些使用普通对象有些使用代理对象 如果没有aop的实现的话，二级缓存就可以了。三级缓存可以解决aop的代理类问题 6.AOP的底层实现 refresh方法的实现 关键方法ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 做了两件事情:读取xml文件(获取非xml的其他的文件或者注解的配置)中的配置;创建BeanFactory 过程： 首先调用refreshBeanFactory();检测是否已经有beanFactory如果有就销毁beanFactory，然后就使用DefaultListableBeanFactory beanFactory = createBeanFactory();创建BeanFactory是DefaultListableBeanFactory对象。这个对象就是容器。 然后就是给beanFactory对象添加个性化定制的参数customizeBeanFactory(beanFactory); 接下来是重点loadBeanDefinitions(beanFactory);这个方法主要是加载xml或者其他方式写的bean定义的配置数据。 先创建一个BeanDefinitionReader对象 设置一些配置 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); //this 是指ApplicationContext对象 然后使用loadBeanDefinitions(beanDefinitionReader)方法加载bean信息。 通过String[] configLocations = getConfigLocations()获取bean的配置，如果是xml文件的话就是XML文件名字。 然后处理加载出来的bean的配置的信息。 //以下方法，依次在方法体内调用下一个方法 int loadBeanDefinitions(String... locations) int loadBeanDefinitions(String location) int loadBeanDefinitions(String location, Set&amp;lt;Resource&amp;gt; actualResources) int loadBeanDefinitions(Resource... resources) int loadBeanDefinitions(Resource resource) int loadBeanDefinitions(EncodedResource encodedResource) 其中int loadBeanDefinitions(EncodedResource encodedResource)这个方法中会将encodedResource的IO流获取到然后调用doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法来加载配置信息。 介绍doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法 我做实现用的xml文件来配置bean。所以这个地方就是从xml中获取bean信息的。Document doc = doLoadDocument(inputSource, resource)就是获取document对象然后交给registerBeanDefinitions(doc, resource)方法做加载最后存放在XmlBeanDefinitionReader中的中的属性BeanFactory的beanDefinitionMap中这个map是bean的名字和BeanDefinition对象。 关键方法prepareBeanFactory(beanFactory); Spel表达式处理组件加载beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); Bean修改组件加载beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); BeanPostProcessor加载beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); 关键方法invokeBeanFactoryPostProcessors(beanFactory)这个方法就是处理上几步注册的BeanFactoryPostProcessor的，这个地方可以扩展，自定义一个BeanFactoryPostProcessor（自定义的类可以实现void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;方法，这个方法还能获取到beanFactory，并做修改或者是一些其他的操作。 关键代码PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());中的PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法的实现 关键方法registerBeanPostProcessors(beanFactory);这个方法是加载BeanPostProcessor的。处理逻辑大致与invokeBeanFactoryPostProcessors处理BeanFactoryPostProcessor的获取processor对象逻辑基本一致，获取之后就加载到beanFactory中然后在初始化bean的时候才会执行这些方法。</summary></entry><entry><title type="html">Spring事务处理</title><link href="/spring/%E4%BA%8B%E5%8A%A1/2019/06/19/spring-shiwu.html" rel="alternate" type="text/html" title="Spring事务处理" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>/spring/%E4%BA%8B%E5%8A%A1/2019/06/19/spring-shiwu</id><content type="html" xml:base="/spring/%E4%BA%8B%E5%8A%A1/2019/06/19/spring-shiwu.html">&lt;h1 id=&quot;spring事务&quot;&gt;Spring事务&lt;/h1&gt;

&lt;h2 id=&quot;1提出的事务解决的问题针对数据库或者可以与数据库事务有相同需求的逻辑都符合acid特征&quot;&gt;1.提出的“事务”解决的问题（针对数据库或者可以与数据库事务有相同需求的逻辑，都符合ACID特征）&lt;/h2&gt;
&lt;p&gt;事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为&lt;strong&gt;ACID特性&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;原子性（atomicity）&lt;/strong&gt;:是说明事务是一个完整的不可分割的执行单位。换句话说，事务中包括的操作要么都做，要么都不做。侧重点说的是整体。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一致性（consistency）&lt;/strong&gt;:事务将数据库从一种一致状态转变为下一种一致状态。所有的操作要么都没有达到期望的数据状态，要么所有的操作之后的数据都达到的期望的数据状态。侧重点说的是所有操作修改数据的状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;隔离性（isolation）&lt;/strong&gt;:一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持久性（durability）&lt;/strong&gt;:持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：个人觉得这种事务解决的问题是一类问题不只限于数据库的“事务”需求。&lt;/p&gt;

&lt;h2 id=&quot;2spring对于数据库事务的实现&quot;&gt;2.Spring对于数据库事务的实现&lt;/h2&gt;

&lt;h2 id=&quot;3事务传播机制&quot;&gt;3.事务传播机制&lt;/h2&gt;

&lt;h2 id=&quot;4事务隔离级别&quot;&gt;4.事务隔离级别&lt;/h2&gt;

&lt;h2 id=&quot;5问题&quot;&gt;5.问题：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;this造成AOP失效导致事务失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;https://www.pianshen.com/article/59731073086/&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;</content><author><name>tyning.another</name></author><category term="Spring" /><category term="事务" /><category term="Spring" /><category term="事务" /><summary type="html">Spring事务 1.提出的“事务”解决的问题（针对数据库或者可以与数据库事务有相同需求的逻辑，都符合ACID特征） 事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（atomicity）:是说明事务是一个完整的不可分割的执行单位。换句话说，事务中包括的操作要么都做，要么都不做。侧重点说的是整体。 一致性（consistency）:事务将数据库从一种一致状态转变为下一种一致状态。所有的操作要么都没有达到期望的数据状态，要么所有的操作之后的数据都达到的期望的数据状态。侧重点说的是所有操作修改数据的状态。 隔离性（isolation）:一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）:持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 注意：个人觉得这种事务解决的问题是一类问题不只限于数据库的“事务”需求。 2.Spring对于数据库事务的实现 3.事务传播机制 4.事务隔离级别 5.问题： this造成AOP失效导致事务失效 https://www.pianshen.com/article/59731073086/ ##</summary></entry><entry><title type="html">Spring</title><link href="/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring.html" rel="alternate" type="text/html" title="Spring" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring</id><content type="html" xml:base="/spring/%E6%BA%90%E7%A0%81/2019/06/19/spring.html">&lt;h1 id=&quot;spring源码&quot;&gt;Spring源码&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/cover2.jpg&quot; alt=&quot;image-20210226150948363&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/image-20210226150948363.png&quot; alt=&quot;image-20210226150948363&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1ioc&quot;&gt;1.IOC&lt;/h2&gt;

&lt;p&gt;存放对象的容器&lt;/p&gt;

&lt;p&gt;如何存储容器对象使用key-value结构&lt;/p&gt;

&lt;p&gt;对象是谁创建？容器&lt;/p&gt;

&lt;p&gt;对象如何创建？new 工厂 反射的方式&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Constructor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clazz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConstructor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;xml与注解只要是为了解决bean定义信息（beandefine）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象默认是单例，可以配置成非单例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;名词：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;bean定义信息（BeanDefinition），一个spring的概念&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读取器（BeanDefinitionReader），一个spring的概念，读取BeanDefinition放到容器中去&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bean工厂（BeanFactory）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象的创建的两个概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实例化：最主要的是在堆中开启一块空间，属性有默认值&lt;/li&gt;
  &lt;li&gt;初始化：
    &lt;ul&gt;
      &lt;li&gt;属性赋值&lt;/li&gt;
      &lt;li&gt;初始化方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实例化之后要初始化，才会生成一个完整的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;postprocessor 后置处理器（增强器）：多xml，没有xml都需要一个公有的值，&lt;/p&gt;

&lt;h1 id=&quot;spirng的启动过程&quot;&gt;Spirng的启动过程&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;obtainFreshBeanFactory()创建BeanFactory(ConfigurableListableBeanFactory类型的对象)
    &lt;ol&gt;
      &lt;li&gt;loadBeanDefinitions()方法创建 reader&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;往BeanFactory中添加东西使用prepareBeanFactory()配置 ClassLoader and post-processors&lt;/li&gt;
  &lt;li&gt;其中invokeBeanFactoryPostProcessors方法是对上边prepareBeanFactory()方法中注入的对象进行处理。这个时候就完成了BeanFactoryPostProcessor过程&lt;/li&gt;
  &lt;li&gt;国际话的一些操作initMessageSource();&lt;/li&gt;
  &lt;li&gt;子类实现来执行这个方法onRefresh();比如springboot&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;bean的生命周期&quot;&gt;Bean的生命周期&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;实现一堆Aware接口（但实现某个Aware接口之后，就意味着可以通过当前bean对象很方便的获取到容器中存在的对象）&lt;/li&gt;
  &lt;li&gt;执行BeanPostProcessor的before方法&lt;/li&gt;
  &lt;li&gt;执行当前对象定义的init方法&lt;/li&gt;
  &lt;li&gt;实例化&lt;/li&gt;
  &lt;li&gt;执行BeanPostProcessor的after方法&lt;/li&gt;
  &lt;li&gt;调用DisposeableBean方法 bean销毁方法&lt;/li&gt;
  &lt;li&gt;调用destory方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;销毁的话是在容器关闭，用户是不能直接销毁对象的&lt;/p&gt;

&lt;h1 id=&quot;6个主要的接口&quot;&gt;6个主要的接口&lt;/h1&gt;

&lt;h2 id=&quot;1beanfactory&quot;&gt;1.BeanFactory&lt;/h2&gt;

&lt;p&gt;The root interface for accessing a Spring bean container.&lt;/p&gt;

&lt;p&gt;用于访问Spring bean容器的根接口&lt;/p&gt;

&lt;p&gt;This is the basic client view of a bean container;&lt;/p&gt;

&lt;p&gt;这是bean容器的基本客户端视图&lt;/p&gt;

&lt;p&gt;further interfaces such as ListableBeanFactory and org.springframework.beans.factory.config.ConfigurableBeanFactory are available for specific purposes.&lt;/p&gt;

&lt;p&gt;还有其他接口，例如{@link ListableBeanFactory}和{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}可用于特定目的。&lt;/p&gt;

&lt;p&gt;This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. “request” and “session” scopes in a web environment).&lt;/p&gt;

&lt;p&gt;该接口由包含多个bean定义的对象实现，每个定义均由String名称唯一标识。根据bean的定义，工厂将返回一个包含对象的独立实例（Prototype设计模式），或者返回一个共享实例（Singleton设计模式的替代方案，其中实例是作用域中的单例）。的工厂）。将返回哪种类型的实例取决于bean工厂的配置：API是相同的。从Spring 2.0开始，取决于具体的应用程序上下文，可以使用更多范围（例如，网络环境中的“ request”和“ session”范围）。&lt;/p&gt;

&lt;p&gt;The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of “Expert One-on-One J2EE Design and Development” for a discussion of the benefits of this approach.&lt;/p&gt;

&lt;p&gt;此方法的重点是BeanFactory是应用程序组件的中央注册表，并集中了应用程序组件的配置（例如，单个对象不再需要读取属性文件）。有关此方法的好处的讨论，请参见“一对一J2EE专家设计和开发”的第4章和第11章。&lt;/p&gt;

&lt;p&gt;Note that it is generally better to rely on Dependency Injection (“push” configuration) to configure application objects through setters or constructors, rather than use any form of “pull” configuration like a BeanFactory lookup. Spring’s Dependency Injection functionality is implemented using this BeanFactory interface and its subinterfaces.&lt;/p&gt;

&lt;p&gt;请注意，通常最好依赖于依赖注入（“ push”配置）通过设置器或构造函数配置应用程序对象，而不是使用任何形式的“ pull”配置（例如BeanFactory查找）。 Spring的Dependency Injection功能是使用此BeanFactory接口及其子接口实现的。&lt;/p&gt;

&lt;p&gt;Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection).&lt;/p&gt;

&lt;p&gt;通常，BeanFactory会加载存储在配置源（例如XML文档）中的Bean定义，并使用{@code org.springframework.beans}包来配置Bean。但是，实现可以根据需要直接在Java代码中直接返回它创建的Java对象。定义的存储方式没有任何限制：LDAP，RDBMS，XML，属性文件等。鼓励实现以支持Bean之间的引用（Dependency Injection）。&lt;/p&gt;

&lt;p&gt;In contrast to the methods in ListableBeanFactory, all of the operations in this interface will also check parent factories if this is a HierarchicalBeanFactory. If a bean is not found in this factory instance, the immediate parent factory will be asked. Beans in this factory instance are supposed to override beans of the same name in any parent factory.&lt;/p&gt;

&lt;p&gt;与{@link ListableBeanFactory}中的方法相比，此接口中的所有操作还将检查父工厂是否为{@link HierarchicalBeanFactory}。如果在此工厂实例中未找到bean，则将询问直接的父工厂。该工厂实例中的Bean应该覆盖任何父工厂中同名的Bean。&lt;/p&gt;

&lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:&lt;/p&gt;

&lt;p&gt;Bean工厂实现应尽可能支持标准Bean生命周期接口。全套初始化方法及其标准顺序为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanNameAware’s setBeanName&lt;/li&gt;
  &lt;li&gt;BeanClassLoaderAware’s setBeanClassLoader&lt;/li&gt;
  &lt;li&gt;BeanFactoryAware’s setBeanFactory&lt;/li&gt;
  &lt;li&gt;EnvironmentAware’s setEnvironment&lt;/li&gt;
  &lt;li&gt;EmbeddedValueResolverAware’s setEmbeddedValueResolver&lt;/li&gt;
  &lt;li&gt;ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ApplicationEventPublisherAware’s setApplicationEventPublisher (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;MessageSourceAware’s setMessageSource (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ApplicationContextAware’s setApplicationContext (only applicable when running in an application context)&lt;/li&gt;
  &lt;li&gt;ServletContextAware’s setServletContext (only applicable when running in a web application context)&lt;/li&gt;
  &lt;li&gt;postProcessBeforeInitialization methods of BeanPostProcessors&lt;/li&gt;
  &lt;li&gt;InitializingBean’s afterPropertiesSet&lt;/li&gt;
  &lt;li&gt;a custom init-method definition&lt;/li&gt;
  &lt;li&gt;postProcessAfterInitialization methods of BeanPostProcessors&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;/p&gt;

&lt;p&gt;在关闭bean工厂的过程中，以下生命周期方法适用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors&lt;/li&gt;
  &lt;li&gt;DisposableBean’s destroy&lt;/li&gt;
  &lt;li&gt;a custom destroy-method definition&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2beanpostprocessor&quot;&gt;2.BeanPostProcessor&lt;/h2&gt;

&lt;p&gt;Factory hook that allows for custom modification of new bean instances — for example, checking for marker interfaces or wrapping beans with proxies.&lt;/p&gt;

&lt;p&gt;工厂挂钩允许对新bean实例进行自定义修改-例如，检查标记接口或使用代理包装bean。&lt;/p&gt;

&lt;p&gt;Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.&lt;/p&gt;

&lt;p&gt;通常，通过标记接口等填充bean的后处理器将实现postProcessBeforeInitialization，而使用代理包装bean的后处理器通常将实现postProcessAfterInitialization。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Registration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;登记注册&lt;/p&gt;

&lt;p&gt;An ApplicationContext can autodetect BeanPostProcessor beans in its bean definitions and apply those post-processors to any beans subsequently created. A plain BeanFactory allows for programmatic registration of post-processors, applying them to all beans created through the bean factory.&lt;/p&gt;

&lt;p&gt;{@code ApplicationContext}可以在其bean定义中自动检测{@code BeanPostProcessor} bean，并将这些后处理器应用于随后创建的任何bean。普通的{@code BeanFactory}允许以编程方式注册&lt;/p&gt;

&lt;p&gt;Ordering&lt;/p&gt;

&lt;p&gt;排序&lt;/p&gt;

&lt;p&gt;BeanPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanPostProcessor beans that are registered programmatically with a BeanFactory will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanPostProcessor beans.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中自动检测到的{@code BeanPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code BeanFactory}以编程方式注册的{@code BeanPostProcessor} bean；以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。&lt;/p&gt;

&lt;h2 id=&quot;3environment&quot;&gt;3.Environment&lt;/h2&gt;

&lt;p&gt;Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.&lt;/p&gt;

&lt;p&gt;表示当前应用程序正在其中运行的环境的接口。为应用程序环境的两个关键方面建模：&lt;em&gt; profiles &lt;em&gt;和&lt;em&gt; properties &lt;em&gt;。与属性访问有关的方法是通过{@link PropertyResolver}超级接口公开的。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the @Profile annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;配置文件&lt;em&gt;是命名的逻辑定义的Bean定义组，仅当给定的配置文件为&lt;em&gt; active &lt;em&gt;时才向容器注册。可以将Bean分配给概要文件，无论是XML定义还是通过注释定义。有关语法的详细信息，请参见spring-beans 3.1模式或{@link org.springframework.context.annotation.Profile @Profile}批注。 {@code Environment}对象与配置文件相关的作用是确定哪些配置文件（如果有的话）当前{@linkplain getActiveProfiles有效}，以及哪些配置文件（如果有的话）应为{@linkplain getDefaultProfiles默认为活动状态}。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt; Properties &lt;em&gt;在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，地图，等等。环境对象与属性有关的作用是为用户提供方便的服务界面，用于配置属性源并从中解析属性。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Beans managed within an ApplicationContext may register to be EnvironmentAware or @Inject the Environment in order to query profile state or resolve properties directly.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中管理的Bean可以注册为{@link org.springframework.context.EnvironmentAware EnvironmentAware}或{@code @Inject} {@code Environment}，以便查询概要文件状态或直接解析属性。&lt;/p&gt;

&lt;p&gt;In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using &lt;context:property-placeholder&gt;&lt;/context:property-placeholder&gt;.&lt;/p&gt;

&lt;p&gt;但是，在大多数情况下，应用程序级Bean无需直接与{@code Environment}进行交互，而可能必须将{@code {…}}属性值替换为诸如{@链接org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer}本身就是{@code EnvironmentAware}，从Spring 3.1开始，默认情况下使用{@code &amp;lt;context：property-placeholder&amp;gt;}注册。&lt;/p&gt;

&lt;p&gt;Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh().&lt;/p&gt;

&lt;p&gt;必须通过从所有{@code AbstractApplicationContext}子类{@code getEnvironment（）}方法返回的{@code ConfigurableEnvironment}接口完成环境对象的配置。请参阅{@link ConfigurableEnvironment} Javadoc以获取使用示例，这些示例演示了在应用程序上下文{@code refresh（）}之前对属性源进行的操作。&lt;/p&gt;

&lt;h2 id=&quot;4factorybean&quot;&gt;4.FactoryBean&lt;/h2&gt;

&lt;p&gt;Interface to be implemented by objects used within a BeanFactory which are themselves factories for individual objects. If a bean implements this interface, it is used as a factory for an object to expose, not directly as a bean instance that will be exposed itself.&lt;/p&gt;

&lt;p&gt;由{@link BeanFactory}中使用的对象实现的接口，这些对象本身就是单个对象的工厂。如果bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。&lt;/p&gt;

&lt;p&gt;NB: A bean that implements this interface cannot be used as a normal bean. A FactoryBean is defined in a bean style, but the object exposed for bean references (getObject()) is always the object that it creates.&lt;/p&gt;

&lt;p&gt;注意：实现此接口的bean不能用作普通bean。&lt;b&gt;  FactoryBean是用bean样式定义的，但是为bean引用公开的对象（getObject（）)始终是它创建的对象。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create objects lazily on demand or eagerly on startup. The SmartFactoryBean interface allows for exposing more fine-grained behavioral metadata.&lt;/p&gt;

&lt;p&gt;FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 {@link SmartFactoryBean}接口允许公开更细粒度的行为元数据&lt;/p&gt;

&lt;p&gt;This interface is heavily used within the framework itself, for example for the AOP org.springframework.aop.framework.ProxyFactoryBean or the org.springframework.jndi.JndiObjectFactoryBean. It can be used for custom components as well; however, this is only common for infrastructure code.&lt;/p&gt;

&lt;p&gt;此接口在框架本身中大量使用，例如用于AOP {@link org.springframework.aop.framework.ProxyFactoryBean}或{@link org.springframework.jndi.JndiObjectFactoryBean}。它也可以用于自定义组件。但是，这仅在基础结构代码中很常见。&lt;/p&gt;

&lt;p&gt;FactoryBean is a programmatic contract. Implementations are not supposed to rely on annotation-driven injection or other reflective facilities. getObjectType() getObject() invocations may arrive early in the bootstrap process, even ahead of any post-processor setup. If you need access to other beans, implement BeanFactoryAware and obtain them programmatically.&lt;/p&gt;

&lt;p&gt;{@code FactoryBean}是程序性合同。实现不应依赖于注释驱动的注入或其他反射性工具。&lt;b&gt; {@link getObjectType（）} {@link getObject（）}调用可能会在引导过程的早期到达，即使在任何后处理器设置之前也是如此。 。如果需要访问其他bean，请实现{@link BeanFactoryAware}并以编程方式获取它们。&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;The container is only responsible for managing the lifecycle of the FactoryBean instance, not the lifecycle of the objects created by the FactoryBean. Therefore, a destroy method on an exposed bean object (such as java.io.Closeable.close() will not be called automatically. Instead, a FactoryBean should implement DisposableBean and delegate any such close call to the underlying object.&lt;/p&gt;

&lt;p&gt;容器仅负责管理FactoryBean实例的生命周期，而不负责管理FactoryBean创建的对象的生命周期。因此，在暴露的bean对象上的destroy方法(例如{@link java.io.Closeableclose（）)将&lt;i&gt;不&lt;i&gt;被自动调用。&lt;/i&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory’s synchronization of bean creation. There is usually no need for internal synchronization other than for purposes of lazy initialization within the FactoryBean itself (or the like).&lt;/p&gt;

&lt;p&gt;最后，FactoryBean对象参与包含BeanFactory的Bean创建同步。除了出于FactoryBean自身（或类似方式）内部的延迟初始化的目的之外，通常不需要内部同步。&lt;/p&gt;

&lt;h2 id=&quot;5beanfactorypostprocessor&quot;&gt;5.BeanFactoryPostProcessor&lt;/h2&gt;

&lt;p&gt;Factory hook that allows for custom modification of an application context’s bean definitions, adapting the bean property values of the context’s underlying bean factory.&lt;/p&gt;

&lt;p&gt;工厂挂钩允许对应用程序上下文的Bean定义进行自定义修改，以适应上下文基础Bean工厂的Bean属性值。&lt;/p&gt;

&lt;p&gt;Useful for custom config files targeted at system administrators that override bean properties configured in the application context. See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.&lt;/p&gt;

&lt;p&gt;对于针对系统管理员的自定义配置文件很有用，这些文件覆盖了在应用程序上下文中配置的Bean属性。请参阅{@link PropertyResourceConfigurer}及其具体实现，以了解解决此类配置需求的即用型解决方案。&lt;/p&gt;

&lt;p&gt;A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.&lt;/p&gt;

&lt;p&gt;{@code BeanFactoryPostProcessor}可以与Bean定义进行交互并对其进行修改，但不能与Bean实例进行交互。这样做可能会导致bean实例化过早，从而违反了容器并造成了意想不到的副作用。如果需要bean实例交互，请考虑改为实现{@link BeanPostProcessor}。&lt;/p&gt;

&lt;p&gt;Registration
An ApplicationContext auto-detects BeanFactoryPostProcessor beans in its bean definitions and applies them before any other beans get created. A BeanFactoryPostProcessor may also be registered programmatically with a ConfigurableApplicationContext.&lt;/p&gt;

&lt;p&gt;{@code ApplicationContext}在其bean定义中自动检测{@code BeanFactoryPostProcessor} bean，并在创建任何其他bean之前应用它们。 {@code BeanFactoryPostProcessor}也可以通过编程方式向{@code ConfigurableApplicationContext}注册&lt;/p&gt;

&lt;p&gt;Ordering
BeanFactoryPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanFactoryPostProcessor beans that are registered programmatically with a ConfigurableApplicationContext will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanFactoryPostProcessor beans.&lt;/p&gt;

&lt;p&gt;在{@code ApplicationContext}中自动检测到的{@code BeanFactoryPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code ConfigurableApplicationContext}以编程方式注册的{@code BeanFactoryPostProcessor} bean。以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanFactoryPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。&lt;/p&gt;

&lt;h2 id=&quot;6beandefinitionreader&quot;&gt;6.BeanDefinitionReader&lt;/h2&gt;

&lt;p&gt;Simple interface for bean definition readers.&lt;/p&gt;

&lt;p&gt;Bean定义阅读器的简单界面。&lt;/p&gt;

&lt;p&gt;Specifies load methods with Resource and String location parameters.&lt;/p&gt;

&lt;p&gt;指定带有“资源”和“字符串”位置参数的加载方法。&lt;/p&gt;

&lt;p&gt;Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format.&lt;/p&gt;

&lt;p&gt;当然，具体的bean定义阅读器可以为bean定义添加特定于其bean定义格式的附加加载和注册方法。&lt;/p&gt;

&lt;p&gt;Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions.&lt;/p&gt;

&lt;p&gt;注意，bean定义阅读器不必实现此接口。它仅对希望遵循标准命名约定的Bean定义读者提供建议。&lt;/p&gt;

&lt;h1 id=&quot;循环依赖的问题&quot;&gt;循环依赖的问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;什么是循环依赖&lt;/li&gt;
  &lt;li&gt;spring中如何解决循环依赖问题&lt;/li&gt;
  &lt;li&gt;为什么要使用三级缓存解决循环依赖问题？一级缓存行不行？二级缓存行不行？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;解答循环依赖&quot;&gt;解答循环依赖&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;基本逻辑:如果使用构造器的方法创建对象的时候必须创建依赖的其他类型对象，可以使用无参构造器创建对象然后使用set方法注入依赖的bean对象。&lt;/li&gt;
  &lt;li&gt;解决依赖的主要类DefaultSingletonBeanRegistry
    &lt;ol&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下边所说的前提：创建的所有对象都是单例对象&lt;/p&gt;

&lt;p&gt;循环依赖问题：&lt;/p&gt;

&lt;p&gt;如果是构造器方式没有办法解决&lt;/p&gt;

&lt;p&gt;如果是setter方式可以使用三级缓存方式解决&lt;/p&gt;

&lt;p&gt;三级缓存就是三个map，区别是在他们的value类型&lt;/p&gt;

&lt;p&gt;其中三级缓存singletonFactories&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@FunctionalInterface&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ObjectFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;cm&quot;&gt;/**
	 * Return an instance (possibly shared or independent)
	 * of the object managed by this factory.
	 * @return the resulting instance
	 * @throws BeansException in case of creation errors
	 */&lt;/span&gt;
	&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BeansException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际执行匿名内部类&lt;/p&gt;

&lt;p&gt;提前暴露对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/image-20210311202715679.png&quot; alt=&quot;image-20210311202715679&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会有两个lambda表达式参数传递&lt;/p&gt;

&lt;p&gt;RuntimeBeanReference 运行时的应用&lt;/p&gt;

&lt;p&gt;从一级缓存 二级缓存 三级缓存&lt;/p&gt;

&lt;h3 id=&quot;为什么非要用三级缓存二级缓存行不行以及行不行&quot;&gt;为什么非要用三级缓存？二级缓存行不行？以及行不行？&lt;/h3&gt;

&lt;p&gt;一级缓存中会放置完整的对象或者非完整对象，如果在操作的时候恰巧获取到非完全对象怎么办？&lt;/p&gt;

&lt;p&gt;一级缓存放完整对象，二级缓存放非完整对象，&lt;/p&gt;

&lt;h3 id=&quot;在创建代理对象的时候需不需要提前创建出属性是默认值的普通对象&quot;&gt;在创建代理对象的时候，需不需要提前创建出属性是默认值的普通对象？&lt;/h3&gt;

&lt;p&gt;一定会创建出普通对象&lt;/p&gt;

&lt;p&gt;当需要创建代理对象的时候，需要执行一个lambda表达式来创建代理类，如果没有三级缓存的话，就有可能有一种情况，刚开始县创建出普通对象，然后被调用了，后续又需要代理对象，此时生成，那么最终使用的效果是有些使用普通对象有些使用代理对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果没有aop的实现的话，二级缓存就可以了。三级缓存可以解决aop的代理类问题&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;6aop的底层实现&quot;&gt;6.AOP的底层实现&lt;/h2&gt;

&lt;h1 id=&quot;refresh方法的实现&quot;&gt;refresh方法的实现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();&lt;/p&gt;

    &lt;p&gt;做了两件事情:读取xml文件(获取非xml的其他的文件或者注解的配置)中的配置;创建BeanFactory&lt;/p&gt;

    &lt;p&gt;过程：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;首先调用refreshBeanFactory();检测是否已经有beanFactory如果有就销毁beanFactory，然后就使用DefaultListableBeanFactory beanFactory = createBeanFactory();创建BeanFactory是DefaultListableBeanFactory对象。这个对象就是&lt;strong&gt;容器&lt;/strong&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;然后就是给beanFactory对象添加个性化定制的参数customizeBeanFactory(beanFactory);&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;接下来是重点loadBeanDefinitions(beanFactory);这个方法主要是加载xml或者其他方式写的bean定义的配置数据。&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;先创建一个BeanDefinitionReader对象&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;设置一些配置&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setResourceLoader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;beanDefinitionReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEntityResolver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResourceEntityResolver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//this 是指ApplicationContext对象&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;然后使用loadBeanDefinitions(beanDefinitionReader)方法加载bean信息。&lt;/p&gt;

            &lt;p&gt;通过String[] configLocations = getConfigLocations()获取bean的配置，如果是xml文件的话就是XML文件名字。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;然后处理加载出来的bean的配置的信息。&lt;/p&gt;

            &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//以下方法，依次在方法体内调用下一个方法&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actualResources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;EncodedResource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encodedResource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;其中int loadBeanDefinitions(EncodedResource encodedResource)这个方法中会将encodedResource的IO流获取到然后调用doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法来加载配置信息。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;介绍doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法&lt;/p&gt;

            &lt;p&gt;我做实现用的xml文件来配置bean。所以这个地方就是从xml中获取bean信息的。Document doc = doLoadDocument(inputSource, resource)就是获取document对象然后交给registerBeanDefinitions(doc, resource)方法做加载最后存放在XmlBeanDefinitionReader中的中的属性BeanFactory的beanDefinitionMap中这个map是bean的名字和BeanDefinition对象。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法prepareBeanFactory(beanFactory);&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Spel表达式处理组件加载beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));&lt;/li&gt;
      &lt;li&gt;Bean修改组件加载beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));&lt;/li&gt;
      &lt;li&gt;BeanPostProcessor加载beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法invokeBeanFactoryPostProcessors(beanFactory)这个方法就是处理上几步注册的BeanFactoryPostProcessor的，&lt;strong&gt;这个地方可以扩展，自定义一个BeanFactoryPostProcessor（自定义的类可以实现void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;方法，这个方法还能获取到beanFactory，并做修改或者是一些其他的操作。&lt;/strong&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关键代码PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());中的PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法的实现
        &lt;ol&gt;
          &lt;li&gt;&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关键方法registerBeanPostProcessors(beanFactory);这个方法是加载BeanPostProcessor的。处理逻辑大致与invokeBeanFactoryPostProcessors处理BeanFactoryPostProcessor的获取processor对象逻辑基本一致，获取之后就加载到beanFactory中然后在初始化bean的时候才会执行这些方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>tyning.another</name></author><category term="Spring" /><category term="源码" /><category term="Spring" /><summary type="html">Spring源码 1.IOC 存放对象的容器 如何存储容器对象使用key-value结构 对象是谁创建？容器 对象如何创建？new 工厂 反射的方式 Class clazz = Person.class; Constructor ctor = clazz.getConstructor(); Object person = ctor.newInstance(); xml与注解只要是为了解决bean定义信息（beandefine） 对象默认是单例，可以配置成非单例 名词： bean定义信息（BeanDefinition），一个spring的概念 读取器（BeanDefinitionReader），一个spring的概念，读取BeanDefinition放到容器中去 bean工厂（BeanFactory） 对象的创建的两个概念： 实例化：最主要的是在堆中开启一块空间，属性有默认值 初始化： 属性赋值 初始化方法 实例化之后要初始化，才会生成一个完整的对象 postprocessor 后置处理器（增强器）：多xml，没有xml都需要一个公有的值， Spirng的启动过程 obtainFreshBeanFactory()创建BeanFactory(ConfigurableListableBeanFactory类型的对象) loadBeanDefinitions()方法创建 reader 往BeanFactory中添加东西使用prepareBeanFactory()配置 ClassLoader and post-processors 其中invokeBeanFactoryPostProcessors方法是对上边prepareBeanFactory()方法中注入的对象进行处理。这个时候就完成了BeanFactoryPostProcessor过程 国际话的一些操作initMessageSource(); 子类实现来执行这个方法onRefresh();比如springboot Bean的生命周期 实现一堆Aware接口（但实现某个Aware接口之后，就意味着可以通过当前bean对象很方便的获取到容器中存在的对象） 执行BeanPostProcessor的before方法 执行当前对象定义的init方法 实例化 执行BeanPostProcessor的after方法 调用DisposeableBean方法 bean销毁方法 调用destory方法 销毁的话是在容器关闭，用户是不能直接销毁对象的 6个主要的接口 1.BeanFactory The root interface for accessing a Spring bean container. 用于访问Spring bean容器的根接口 This is the basic client view of a bean container; 这是bean容器的基本客户端视图 further interfaces such as ListableBeanFactory and org.springframework.beans.factory.config.ConfigurableBeanFactory are available for specific purposes. 还有其他接口，例如{@link ListableBeanFactory}和{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}可用于特定目的。 This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance (a superior alternative to the Singleton design pattern, in which the instance is a singleton in the scope of the factory). Which type of instance will be returned depends on the bean factory configuration: the API is the same. Since Spring 2.0, further scopes are available depending on the concrete application context (e.g. “request” and “session” scopes in a web environment). 该接口由包含多个bean定义的对象实现，每个定义均由String名称唯一标识。根据bean的定义，工厂将返回一个包含对象的独立实例（Prototype设计模式），或者返回一个共享实例（Singleton设计模式的替代方案，其中实例是作用域中的单例）。的工厂）。将返回哪种类型的实例取决于bean工厂的配置：API是相同的。从Spring 2.0开始，取决于具体的应用程序上下文，可以使用更多范围（例如，网络环境中的“ request”和“ session”范围）。 The point of this approach is that the BeanFactory is a central registry of application components, and centralizes configuration of application components (no more do individual objects need to read properties files, for example). See chapters 4 and 11 of “Expert One-on-One J2EE Design and Development” for a discussion of the benefits of this approach. 此方法的重点是BeanFactory是应用程序组件的中央注册表，并集中了应用程序组件的配置（例如，单个对象不再需要读取属性文件）。有关此方法的好处的讨论，请参见“一对一J2EE专家设计和开发”的第4章和第11章。 Note that it is generally better to rely on Dependency Injection (“push” configuration) to configure application objects through setters or constructors, rather than use any form of “pull” configuration like a BeanFactory lookup. Spring’s Dependency Injection functionality is implemented using this BeanFactory interface and its subinterfaces. 请注意，通常最好依赖于依赖注入（“ push”配置）通过设置器或构造函数配置应用程序对象，而不是使用任何形式的“ pull”配置（例如BeanFactory查找）。 Spring的Dependency Injection功能是使用此BeanFactory接口及其子接口实现的。 Normally a BeanFactory will load bean definitions stored in a configuration source (such as an XML document), and use the org.springframework.beans package to configure the beans. However, an implementation could simply return Java objects it creates as necessary directly in Java code. There are no constraints on how the definitions could be stored: LDAP, RDBMS, XML, properties file, etc. Implementations are encouraged to support references amongst beans (Dependency Injection). 通常，BeanFactory会加载存储在配置源（例如XML文档）中的Bean定义，并使用{@code org.springframework.beans}包来配置Bean。但是，实现可以根据需要直接在Java代码中直接返回它创建的Java对象。定义的存储方式没有任何限制：LDAP，RDBMS，XML，属性文件等。鼓励实现以支持Bean之间的引用（Dependency Injection）。 In contrast to the methods in ListableBeanFactory, all of the operations in this interface will also check parent factories if this is a HierarchicalBeanFactory. If a bean is not found in this factory instance, the immediate parent factory will be asked. Beans in this factory instance are supposed to override beans of the same name in any parent factory. 与{@link ListableBeanFactory}中的方法相比，此接口中的所有操作还将检查父工厂是否为{@link HierarchicalBeanFactory}。如果在此工厂实例中未找到bean，则将询问直接的父工厂。该工厂实例中的Bean应该覆盖任何父工厂中同名的Bean。 Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is: Bean工厂实现应尽可能支持标准Bean生命周期接口。全套初始化方法及其标准顺序为： BeanNameAware’s setBeanName BeanClassLoaderAware’s setBeanClassLoader BeanFactoryAware’s setBeanFactory EnvironmentAware’s setEnvironment EmbeddedValueResolverAware’s setEmbeddedValueResolver ResourceLoaderAware’s setResourceLoader (only applicable when running in an application context) ApplicationEventPublisherAware’s setApplicationEventPublisher (only applicable when running in an application context) MessageSourceAware’s setMessageSource (only applicable when running in an application context) ApplicationContextAware’s setApplicationContext (only applicable when running in an application context) ServletContextAware’s setServletContext (only applicable when running in a web application context) postProcessBeforeInitialization methods of BeanPostProcessors InitializingBean’s afterPropertiesSet a custom init-method definition postProcessAfterInitialization methods of BeanPostProcessors On shutdown of a bean factory, the following lifecycle methods apply: 在关闭bean工厂的过程中，以下生命周期方法适用： postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors DisposableBean’s destroy a custom destroy-method definition 2.BeanPostProcessor Factory hook that allows for custom modification of new bean instances — for example, checking for marker interfaces or wrapping beans with proxies. 工厂挂钩允许对新bean实例进行自定义修改-例如，检查标记接口或使用代理包装bean。 Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization. 通常，通过标记接口等填充bean的后处理器将实现postProcessBeforeInitialization，而使用代理包装bean的后处理器通常将实现postProcessAfterInitialization。 Registration 登记注册 An ApplicationContext can autodetect BeanPostProcessor beans in its bean definitions and apply those post-processors to any beans subsequently created. A plain BeanFactory allows for programmatic registration of post-processors, applying them to all beans created through the bean factory. {@code ApplicationContext}可以在其bean定义中自动检测{@code BeanPostProcessor} bean，并将这些后处理器应用于随后创建的任何bean。普通的{@code BeanFactory}允许以编程方式注册 Ordering 排序 BeanPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanPostProcessor beans that are registered programmatically with a BeanFactory will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanPostProcessor beans. 在{@code ApplicationContext}中自动检测到的{@code BeanPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code BeanFactory}以编程方式注册的{@code BeanPostProcessor} bean；以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。 3.Environment Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface. 表示当前应用程序正在其中运行的环境的接口。为应用程序环境的两个关键方面建模： profiles 和 properties 。与属性访问有关的方法是通过{@link PropertyResolver}超级接口公开的。 A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the @Profile annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. 配置文件是命名的逻辑定义的Bean定义组，仅当给定的配置文件为 active 时才向容器注册。可以将Bean分配给概要文件，无论是XML定义还是通过注释定义。有关语法的详细信息，请参见spring-beans 3.1模式或{@link org.springframework.context.annotation.Profile @Profile}批注。 {@code Environment}对象与配置文件相关的作用是确定哪些配置文件（如果有的话）当前{@linkplain getActiveProfiles有效}，以及哪些配置文件（如果有的话）应为{@linkplain getDefaultProfiles默认为活动状态}。 Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them. Properties 在几乎所有应用程序中都起着重要作用，并且可能源自多种来源：属性文件，JVM系统属性，系统环境变量，JNDI，Servlet上下文参数，临时属性对象，地图，等等。环境对象与属性有关的作用是为用户提供方便的服务界面，用于配置属性源并从中解析属性。 Beans managed within an ApplicationContext may register to be EnvironmentAware or @Inject the Environment in order to query profile state or resolve properties directly. 在{@code ApplicationContext}中管理的Bean可以注册为{@link org.springframework.context.EnvironmentAware EnvironmentAware}或{@code @Inject} {@code Environment}，以便查询概要文件状态或直接解析属性。 In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using . 但是，在大多数情况下，应用程序级Bean无需直接与{@code Environment}进行交互，而可能必须将{@code {…}}属性值替换为诸如{@链接org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer}本身就是{@code EnvironmentAware}，从Spring 3.1开始，默认情况下使用{@code &amp;lt;context：property-placeholder&amp;gt;}注册。 Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh(). 必须通过从所有{@code AbstractApplicationContext}子类{@code getEnvironment（）}方法返回的{@code ConfigurableEnvironment}接口完成环境对象的配置。请参阅{@link ConfigurableEnvironment} Javadoc以获取使用示例，这些示例演示了在应用程序上下文{@code refresh（）}之前对属性源进行的操作。 4.FactoryBean Interface to be implemented by objects used within a BeanFactory which are themselves factories for individual objects. If a bean implements this interface, it is used as a factory for an object to expose, not directly as a bean instance that will be exposed itself. 由{@link BeanFactory}中使用的对象实现的接口，这些对象本身就是单个对象的工厂。如果bean实现此接口，则它将用作对象公开的工厂，而不是直接用作将自身公开的bean实例。 NB: A bean that implements this interface cannot be used as a normal bean. A FactoryBean is defined in a bean style, but the object exposed for bean references (getObject()) is always the object that it creates. 注意：实现此接口的bean不能用作普通bean。 FactoryBean是用bean样式定义的，但是为bean引用公开的对象（getObject（）)始终是它创建的对象。 FactoryBeans can support singletons and prototypes, and can either create objects lazily on demand or eagerly on startup. The SmartFactoryBean interface allows for exposing more fine-grained behavioral metadata. FactoryBeans可以支持单例和原型，并且可以按需延迟创建对象，也可以在启动时急于创建对象。 {@link SmartFactoryBean}接口允许公开更细粒度的行为元数据 This interface is heavily used within the framework itself, for example for the AOP org.springframework.aop.framework.ProxyFactoryBean or the org.springframework.jndi.JndiObjectFactoryBean. It can be used for custom components as well; however, this is only common for infrastructure code. 此接口在框架本身中大量使用，例如用于AOP {@link org.springframework.aop.framework.ProxyFactoryBean}或{@link org.springframework.jndi.JndiObjectFactoryBean}。它也可以用于自定义组件。但是，这仅在基础结构代码中很常见。 FactoryBean is a programmatic contract. Implementations are not supposed to rely on annotation-driven injection or other reflective facilities. getObjectType() getObject() invocations may arrive early in the bootstrap process, even ahead of any post-processor setup. If you need access to other beans, implement BeanFactoryAware and obtain them programmatically. {@code FactoryBean}是程序性合同。实现不应依赖于注释驱动的注入或其他反射性工具。 {@link getObjectType（）} {@link getObject（）}调用可能会在引导过程的早期到达，即使在任何后处理器设置之前也是如此。 。如果需要访问其他bean，请实现{@link BeanFactoryAware}并以编程方式获取它们。 The container is only responsible for managing the lifecycle of the FactoryBean instance, not the lifecycle of the objects created by the FactoryBean. Therefore, a destroy method on an exposed bean object (such as java.io.Closeable.close() will not be called automatically. Instead, a FactoryBean should implement DisposableBean and delegate any such close call to the underlying object. 容器仅负责管理FactoryBean实例的生命周期，而不负责管理FactoryBean创建的对象的生命周期。因此，在暴露的bean对象上的destroy方法(例如{@link java.io.Closeableclose（）)将不被自动调用。 Finally, FactoryBean objects participate in the containing BeanFactory’s synchronization of bean creation. There is usually no need for internal synchronization other than for purposes of lazy initialization within the FactoryBean itself (or the like). 最后，FactoryBean对象参与包含BeanFactory的Bean创建同步。除了出于FactoryBean自身（或类似方式）内部的延迟初始化的目的之外，通常不需要内部同步。 5.BeanFactoryPostProcessor Factory hook that allows for custom modification of an application context’s bean definitions, adapting the bean property values of the context’s underlying bean factory. 工厂挂钩允许对应用程序上下文的Bean定义进行自定义修改，以适应上下文基础Bean工厂的Bean属性值。 Useful for custom config files targeted at system administrators that override bean properties configured in the application context. See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs. 对于针对系统管理员的自定义配置文件很有用，这些文件覆盖了在应用程序上下文中配置的Bean属性。请参阅{@link PropertyResourceConfigurer}及其具体实现，以了解解决此类配置需求的即用型解决方案。 A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead. {@code BeanFactoryPostProcessor}可以与Bean定义进行交互并对其进行修改，但不能与Bean实例进行交互。这样做可能会导致bean实例化过早，从而违反了容器并造成了意想不到的副作用。如果需要bean实例交互，请考虑改为实现{@link BeanPostProcessor}。 Registration An ApplicationContext auto-detects BeanFactoryPostProcessor beans in its bean definitions and applies them before any other beans get created. A BeanFactoryPostProcessor may also be registered programmatically with a ConfigurableApplicationContext. {@code ApplicationContext}在其bean定义中自动检测{@code BeanFactoryPostProcessor} bean，并在创建任何其他bean之前应用它们。 {@code BeanFactoryPostProcessor}也可以通过编程方式向{@code ConfigurableApplicationContext}注册 Ordering BeanFactoryPostProcessor beans that are autodetected in an ApplicationContext will be ordered according to org.springframework.core.PriorityOrdered and org.springframework.core.Ordered semantics. In contrast, BeanFactoryPostProcessor beans that are registered programmatically with a ConfigurableApplicationContext will be applied in the order of registration; any ordering semantics expressed through implementing the PriorityOrdered or Ordered interface will be ignored for programmatically registered post-processors. Furthermore, the @Order annotation is not taken into account for BeanFactoryPostProcessor beans. 在{@code ApplicationContext}中自动检测到的{@code BeanFactoryPostProcessor} bean将根据{@link org.springframework.core.PriorityOrdered}和{@link org.springframework.core.Ordered}语义进行排序。相反，将以注册顺序应用通过{@code ConfigurableApplicationContext}以编程方式注册的{@code BeanFactoryPostProcessor} bean。以编程方式注册的后处理器将忽略通过实现{@code PriorityOrdered}或{@code Ordered}接口表示的任何排序语义。此外，{@ code BeanFactoryPostProcessor} bean不考虑{@link org.springframework.core.annotation.Order @Order}批注。 6.BeanDefinitionReader Simple interface for bean definition readers. Bean定义阅读器的简单界面。 Specifies load methods with Resource and String location parameters. 指定带有“资源”和“字符串”位置参数的加载方法。 Concrete bean definition readers can of course add additional load and register methods for bean definitions, specific to their bean definition format. 当然，具体的bean定义阅读器可以为bean定义添加特定于其bean定义格式的附加加载和注册方法。 Note that a bean definition reader does not have to implement this interface. It only serves as suggestion for bean definition readers that want to follow standard naming conventions. 注意，bean定义阅读器不必实现此接口。它仅对希望遵循标准命名约定的Bean定义读者提供建议。 循环依赖的问题 什么是循环依赖 spring中如何解决循环依赖问题 为什么要使用三级缓存解决循环依赖问题？一级缓存行不行？二级缓存行不行？ 解答循环依赖 基本逻辑:如果使用构造器的方法创建对象的时候必须创建依赖的其他类型对象，可以使用无参构造器创建对象然后使用set方法注入依赖的bean对象。 解决依赖的主要类DefaultSingletonBeanRegistry 下边所说的前提：创建的所有对象都是单例对象 循环依赖问题： 如果是构造器方式没有办法解决 如果是setter方式可以使用三级缓存方式解决 三级缓存就是三个map，区别是在他们的value类型 其中三级缓存singletonFactories @FunctionalInterface public interface ObjectFactory&amp;lt;T&amp;gt; { /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return the resulting instance * @throws BeansException in case of creation errors */ T getObject() throws BeansException; } 实际执行匿名内部类 提前暴露对象 会有两个lambda表达式参数传递 RuntimeBeanReference 运行时的应用 从一级缓存 二级缓存 三级缓存 为什么非要用三级缓存？二级缓存行不行？以及行不行？ 一级缓存中会放置完整的对象或者非完整对象，如果在操作的时候恰巧获取到非完全对象怎么办？ 一级缓存放完整对象，二级缓存放非完整对象， 在创建代理对象的时候，需不需要提前创建出属性是默认值的普通对象？ 一定会创建出普通对象 当需要创建代理对象的时候，需要执行一个lambda表达式来创建代理类，如果没有三级缓存的话，就有可能有一种情况，刚开始县创建出普通对象，然后被调用了，后续又需要代理对象，此时生成，那么最终使用的效果是有些使用普通对象有些使用代理对象 如果没有aop的实现的话，二级缓存就可以了。三级缓存可以解决aop的代理类问题 6.AOP的底层实现 refresh方法的实现 关键方法ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 做了两件事情:读取xml文件(获取非xml的其他的文件或者注解的配置)中的配置;创建BeanFactory 过程： 首先调用refreshBeanFactory();检测是否已经有beanFactory如果有就销毁beanFactory，然后就使用DefaultListableBeanFactory beanFactory = createBeanFactory();创建BeanFactory是DefaultListableBeanFactory对象。这个对象就是容器。 然后就是给beanFactory对象添加个性化定制的参数customizeBeanFactory(beanFactory); 接下来是重点loadBeanDefinitions(beanFactory);这个方法主要是加载xml或者其他方式写的bean定义的配置数据。 先创建一个BeanDefinitionReader对象 设置一些配置 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); //this 是指ApplicationContext对象 然后使用loadBeanDefinitions(beanDefinitionReader)方法加载bean信息。 通过String[] configLocations = getConfigLocations()获取bean的配置，如果是xml文件的话就是XML文件名字。 然后处理加载出来的bean的配置的信息。 //以下方法，依次在方法体内调用下一个方法 int loadBeanDefinitions(String... locations) int loadBeanDefinitions(String location) int loadBeanDefinitions(String location, Set&amp;lt;Resource&amp;gt; actualResources) int loadBeanDefinitions(Resource... resources) int loadBeanDefinitions(Resource resource) int loadBeanDefinitions(EncodedResource encodedResource) 其中int loadBeanDefinitions(EncodedResource encodedResource)这个方法中会将encodedResource的IO流获取到然后调用doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法来加载配置信息。 介绍doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法 我做实现用的xml文件来配置bean。所以这个地方就是从xml中获取bean信息的。Document doc = doLoadDocument(inputSource, resource)就是获取document对象然后交给registerBeanDefinitions(doc, resource)方法做加载最后存放在XmlBeanDefinitionReader中的中的属性BeanFactory的beanDefinitionMap中这个map是bean的名字和BeanDefinition对象。 关键方法prepareBeanFactory(beanFactory); Spel表达式处理组件加载beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); Bean修改组件加载beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); BeanPostProcessor加载beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); 关键方法invokeBeanFactoryPostProcessors(beanFactory)这个方法就是处理上几步注册的BeanFactoryPostProcessor的，这个地方可以扩展，自定义一个BeanFactoryPostProcessor（自定义的类可以实现void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;方法，这个方法还能获取到beanFactory，并做修改或者是一些其他的操作。 关键代码PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());中的PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法的实现 关键方法registerBeanPostProcessors(beanFactory);这个方法是加载BeanPostProcessor的。处理逻辑大致与invokeBeanFactoryPostProcessors处理BeanFactoryPostProcessor的获取processor对象逻辑基本一致，获取之后就加载到beanFactory中然后在初始化bean的时候才会执行这些方法。</summary></entry><entry><title type="html">Redis基础</title><link href="/redis/2019/05/20/redis.html" rel="alternate" type="text/html" title="Redis基础" /><published>2019-05-20T00:00:00+08:00</published><updated>2019-05-20T00:00:00+08:00</updated><id>/redis/2019/05/20/redis</id><content type="html" xml:base="/redis/2019/05/20/redis.html">&lt;h1 id=&quot;redis&quot;&gt;Redis&lt;/h1&gt;

&lt;h1 id=&quot;一redis五种数据类型&quot;&gt;一、redis五种数据类型&lt;/h1&gt;

&lt;p&gt;一、redis五种数据类型&lt;/p&gt;

 	1. String 
 	 	最大能存储 512MB
 	2. list
 	3. set无序集合
 	4. zset有顺序不能重复
 	5. hash数据类型

&lt;p&gt;二、redis集群（多台服务器）
	三种模式：主从模式、Sentinel模式（哨兵模式）、Cluster模式
	主从：数据库分两类 主数据master库和从数据库slave
	Sentinel模式（哨兵模式）：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;主从复制：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;1-redis-是什么都有哪些使用场景&quot;&gt;1. redis 是什么？都有哪些使用场景？&lt;/h2&gt;

&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;

&lt;p&gt;Redis 使用场景：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据高并发的读写&lt;/li&gt;
  &lt;li&gt;海量数据的读写&lt;/li&gt;
  &lt;li&gt;对扩展性要求高的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-redis-有哪些功能&quot;&gt;2. redis 有哪些功能？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数据缓存功能&lt;/li&gt;
  &lt;li&gt;分布式锁的功能&lt;/li&gt;
  &lt;li&gt;支持数据持久化&lt;/li&gt;
  &lt;li&gt;支持事务&lt;/li&gt;
  &lt;li&gt;支持消息队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-redis-和-memecache-有什么区别&quot;&gt;3. redis 和 memecache 有什么区别？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型&lt;/li&gt;
  &lt;li&gt;redis的速度比memcached快很多&lt;/li&gt;
  &lt;li&gt;redis可以持久化其数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-redis-为什么是单线程的&quot;&gt;4. redis 为什么是单线程的？&lt;/h2&gt;
&lt;p&gt;因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。&lt;/p&gt;

&lt;p&gt;关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。&lt;/p&gt;

&lt;p&gt;而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。&lt;/p&gt;

&lt;h2 id=&quot;5-什么是缓存穿透怎么解决&quot;&gt;5. 什么是缓存穿透？怎么解决？&lt;/h2&gt;

&lt;p&gt;缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。&lt;/p&gt;

&lt;p&gt;解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。&lt;/p&gt;

&lt;h2 id=&quot;6-redis-支持的数据类型有哪些&quot;&gt;6. redis 支持的数据类型有哪些？&lt;/h2&gt;
&lt;p&gt;string、list、hash、set、zset。&lt;/p&gt;

&lt;p&gt;String、List、Set、Sorted Set、hashes&lt;/p&gt;

&lt;h2 id=&quot;7-redis-支持的-java-客户端都有哪些&quot;&gt;7. redis 支持的 java 客户端都有哪些？&lt;/h2&gt;
&lt;p&gt;Redisson、Jedis、lettuce等等，官方推荐使用Redisson。&lt;/p&gt;
&lt;h2 id=&quot;8-jedis-和-redisson-有哪些区别&quot;&gt;8. jedis 和 redisson 有哪些区别？&lt;/h2&gt;
&lt;p&gt;Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。&lt;/p&gt;

&lt;p&gt;Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。&lt;/p&gt;

&lt;h2 id=&quot;9-怎么保证缓存和数据库数据的一致性&quot;&gt;9. 怎么保证缓存和数据库数据的一致性？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;合理设置缓存的过期时间。&lt;/li&gt;
  &lt;li&gt;新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;10-redis-持久化有几种方式&quot;&gt;10. redis 持久化有几种方式？&lt;/h2&gt;
&lt;p&gt;Redis 的持久化有两种方式，或者说有两种策略：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。&lt;/li&gt;
  &lt;li&gt;AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-redis-怎么实现分布式锁&quot;&gt;11. redis 怎么实现分布式锁？&lt;/h2&gt;

&lt;p&gt;Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。&lt;/p&gt;

&lt;p&gt;占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。&lt;/p&gt;

&lt;h2 id=&quot;12-redis-分布式锁有什么缺陷&quot;&gt;12. redis 分布式锁有什么缺陷？&lt;/h2&gt;

&lt;p&gt;Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。&lt;/p&gt;

&lt;h2 id=&quot;13-redis-如何做内存优化&quot;&gt;13. redis 如何做内存优化？&lt;/h2&gt;

&lt;p&gt;尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。&lt;/p&gt;

&lt;p&gt;比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。&lt;/p&gt;

&lt;h2 id=&quot;14-redis-淘汰策略有哪些&quot;&gt;14. redis 淘汰策略有哪些？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。尝试回收最少使用的键(LRU)，但仅限于在过期集合的键,使得新添加的数据有空间存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。回收在过期集合的键，并且优先回收存活 时间(TTL)较短的键,使得新添加的数据有空间 存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。尝试回收最少使用的键(LRU)，使得新添加的数据有空间存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。回收随机的键使得新添加的数据有空间存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;no-enviction（驱逐）：禁止驱逐数据。返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;15-redis-常见的性能问题有哪些该如何解决&quot;&gt;15. redis 常见的性能问题有哪些？该如何解决？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1、 什么是 Redis?简述它的优缺点?
 Redis 的全称是:Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘 上进行保存。
 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。
 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限 制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。 比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高 性能的 tag 系统等等。
 另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能 读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。&lt;/p&gt;

&lt;p&gt;3、Redis 支持哪几种数据类型?&lt;/p&gt;

&lt;p&gt;4、Redis 主要消耗什么物理资源?
 内存。&lt;/p&gt;

&lt;p&gt;6、Redis 官方为什么不提供 Windows 版本?
 因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问 题。
 7、一个字符串类型的值能存储最大容量是多少?
 512M
 8、为什么 Redis 需要把所有数据放到内存中?
 Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。
 所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的 性能。
 在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达 到内存限值后不能继续插入新值。
 9、Redis 集群方案应该怎么做?都有哪些方案?
 1.codis&lt;/p&gt;

&lt;p&gt;2.目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点 数据可恢复到新 hash 节点。
 redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自 身支持节点设置从节点。具体看官方文档介绍。&lt;/p&gt;

&lt;p&gt;3.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方 案，数据震荡后的自动脚本恢复，实例的监控，等等。
 欢迎工作一到五年的 Java 工程师朋友们加入 Java 进阶架构学习交流:952124565，群内提供免费的 Java 架构学习资料(里面有高可用、高并发、高性能及分布式、Jvm 性能调优、Spring 源码， MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx 等多个知识点的架构资 料)合理利用自己每一分每一秒的时间来学习提升自己，不要再用”没有时间“来掩饰自己思想上的懒 惰!趁年轻，使劲拼，给未来的自己一个交代!&lt;/p&gt;

&lt;p&gt;10、Redis 集群方案什么情况下会导致整个集群不可用?
 有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。
 11、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据? redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
 其实面试除了考察 Redis，不少公司都很重视高并发高可用的技术，特别是一线互联网公司，分布式、 JVM、spring 源码分析、微服务等知识点已是面试的必考题。我自己整理收集了一套系统的架构技术体 系，针对当前互联网公司的技术需求以及结合主流技术，这些东西可能你们平时在工作中接触过，但是缺 少的全面系统的学习，加入后端开发群:943918498，或是关注微信公众号:Java 资讯库，回复“架 构”，免费领取架构资料。
 12、Redis 有哪些适合的场景?
 (1)会话缓存(Session Cache)
 最常用的一种使用 Redis 的情景是会话缓存(sessioncache)，用 Redis 缓存会话比其他存储(如 Memcached)的优势在于:Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的 购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗?
 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为 人知的商业平台 Magento 也提供 Redis 的插件。
 (2)全页缓存(FPC)
 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实 例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。
 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。
 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快 速度加载你曾浏览过的页面。
 (3)队列
 Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列 平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言(如 Python)对 list 的 push/pop 操作。
 如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的 就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。
 (4)排行榜/计数器&lt;/p&gt;

&lt;p&gt;Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合(Set)和有序集合(SortedSet)也使 得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。 所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像 下面一样执行即可: 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执 行:&lt;/p&gt;

&lt;p&gt;ZRANGE user_scores 0 10 WITHSCORES
 Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可 以在这里看到。
 (5)发布/订阅
 最后(但肯定不是最不重要的)是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见 人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建 立聊天系统!
 13、Redis 支持的 Java 客户端都有哪些?官方推荐用哪个?
 Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。
 14、Redis 和 Redisson 有什么关系?
 Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。
 15、Jedis 与 Redisson 对比有什么优缺点?
 Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持;
 Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从 而让使用者能够将精力更集中地放在处理业务逻辑上。
 16、说说 Redis 哈希槽的概念?
 Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通 过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。
 17、Redis 集群的主从复制模型是怎样的? 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型, 每个节点都会有 N-1 个复制品.
 18、Redis 集群会有写操作丢失吗?为什么?
 Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 19、Redis 集群之间是如何复制的?
 异步复制
 20、Redis 集群最大节点个数是多少?
 16384 个
 21、Redis 集群如何选择数据库?
 Redis 集群目前无法做数据库选择，默认在 0 数据库。
 22、Redis 中的管道有什么用? 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务 器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道(pipelining)，是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功 能，大大加快了从服务器下载新邮件的过程。&lt;/p&gt;

&lt;p&gt;23、怎么理解 Redis 事务? 事务是一个单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会 被其他客户端发送来的命令请求所打断。 事务是一个原子操作:事务中的命令要么全部被执行，要么全部都不执行。
 24、Redis 事务相关的命令有哪几个?
 MULTI、EXEC、DISCARD、WATCH
 25、Redis key 的过期时间和永久有效分别怎么设置?
 EXPIRE 和 PERSIST 命令
 26、Redis 如何做内存优化? 尽可能使用散列表(hashes)，散列表(是说散列表里面存储的数少)使用的内存非常小，所以你应该 尽可能的将你的数据模型抽象到一个散列表里面。
 比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是 应该把这个用户的所有信息存储到一张散列表里面。
 27、Redis 回收进程如何工作的?
 一个客户端运行了新的命令，添加了新的数据。
 Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限 制就会被这个内存使用量超越。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28.&lt;/strong&gt;加锁机制&lt;/p&gt;

&lt;p&gt;咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集 群，他首先会根据 hash 节点选择一台机器。这里注意，仅仅只是选择一台机器!这点很关 键!紧接着，就会发送一段 lua 脚本到 redis 上，那段 lua 脚本如下所示:&lt;/p&gt;

&lt;p&gt;为啥要用 lua 脚本呢?因为一大坨复杂的业务逻辑，可以通过封装在 lua 脚本中发送给 redis， 保证这段复杂业务逻辑执行的原子性。&lt;/p&gt;

&lt;p&gt;那么，这段 lua 脚本是什么意思呢?这里 &lt;strong&gt;KEYS[1]&lt;/strong&gt;代表的是你加锁的那个 key，比如说:RLoc k lock = redisson.getLock(“myLock”);这里你自己设置了加锁的那个锁key就是“myLock”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARGV[1]&lt;/strong&gt;代表的就是锁 key 的默认生存时间，默认 30 秒。&lt;strong&gt;ARGV[2]&lt;/strong&gt;代表的是加锁的客户端的 I D，类似于下面这样:8743c9c0-0795-4907-87fd-6c719a6b4586:1&lt;/p&gt;

&lt;p&gt;给大家解释一下，第一段if判断语句，就是用“&lt;strong&gt;exists myLock&lt;/strong&gt;”命令判断一下，如果你要加锁 的那个锁key不存在的话，你就进行加锁。如何加锁呢?很简单，用下面的命令:hset myLoc k&lt;/p&gt;

&lt;p&gt;8743c9c0-0795-4907-87fd-6c719a6b4586:1 1，通过这个命令设置一个hash数据结构，这行 命令执行后，会出现一个类似下面的数据结构:&lt;/p&gt;

&lt;p&gt;上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁 key 完 成了加锁。接着会执行“&lt;strong&gt;pexpire myLock 30000&lt;/strong&gt;”命令，设置myLock这个锁key的生存时间 是 &lt;strong&gt;30&lt;/strong&gt; 秒。好了，到此为止，ok，加锁完成了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29.&lt;/strong&gt;锁互斥机制&lt;/p&gt;

&lt;p&gt;那么在这个时候，如果客户端 2 来尝试加锁，执行了同样的一段 lua 脚本，会咋样呢?很简 单，第一个if判断会执行“&lt;strong&gt;exists myLock&lt;/strong&gt;”，发现myLock这个锁key已经存在了。接着第二 个 if 判断，判断一下，myLock 锁 key 的 hash 数据结构中，是否包含客户端 2 的 ID，但是明 显不是的，因为那里包含的是客户端 1 的 ID。&lt;/p&gt;

&lt;p&gt;所以，客户端2会获取到&lt;strong&gt;pttl myLock&lt;/strong&gt;返回的一个数字，这个数字代表了myLock这个锁key 的剩余生存时间。比如还剩 15000 毫秒的生存时间。此时客户端 2 会进入一个 while 循环，不 停的尝试加锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30.watch dog&lt;/strong&gt; 自动延期机制
 客户端 1 加锁的锁 key 默认生存时间才 30 秒，如果超过了 30 秒，客户端 1 还想一直持有这把&lt;/p&gt;

&lt;p&gt;锁，怎么办呢?
 简单!只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会&lt;/p&gt;

&lt;p&gt;每隔 &lt;strong&gt;10&lt;/strong&gt; 秒检查一下，如果客户端 1 还持有锁 key，那么就会不断的延长锁 key 的生存时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31.&lt;/strong&gt;可重入加锁机制
 那如果客户端 1 都已经持有了这把锁了，结果可重入的加锁会怎么样呢?比如下面这种代码:&lt;/p&gt;

&lt;p&gt;这时我们来分析一下上面那段lua脚本。第一个&lt;strong&gt;if&lt;/strong&gt;判断肯定不成立，“exists myLock”会显示锁 key 已经存在了。第二个 &lt;strong&gt;if&lt;/strong&gt; 判断会成立，因为 myLock 的 hash 数据结构中包含的那个 ID，就 是客户端 1 的那个 ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”&lt;/p&gt;

&lt;p&gt;此时就会执行可重入加锁的逻辑，他会用:
 incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1 ，通过这个命令，对客户端1&lt;/p&gt;

&lt;p&gt;的加锁次数，累加 1。此时 myLock 数据结构变为下面这样:&lt;/p&gt;

&lt;p&gt;大家看到了吧，那个 myLock 的 hash 数据结构中的那个客户端 ID，就对应着加锁的次数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;32.&lt;/strong&gt;释放锁机制&lt;/p&gt;

&lt;p&gt;如果执行 lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白 了，就是每次都对 myLock 数据结构中的那个加锁次数减 1。如果发现加锁次数是 0 了，说明 这个客户端已经不再持有锁了，此时就会用:&lt;strong&gt;“del myLock”&lt;/strong&gt;命令，从redis里删除这个key。 然后呢，另外的客户端 2 就可以尝试完成加锁了。这就是所谓的分布式锁的开源 &lt;strong&gt;Redisson&lt;/strong&gt; 框 架的实现机制。&lt;/p&gt;

&lt;p&gt;一般我们在生产系统中，可以用 Redisson 框架提供的这个类库来基于 redis 进行分布式锁的加 锁与释放锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;33.&lt;/strong&gt;上述 &lt;strong&gt;Redis&lt;/strong&gt; 分布式锁的缺点&lt;/p&gt;

&lt;p&gt;其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁 key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis m aster宕机，主备切换，redis slave变为了redis master。&lt;/p&gt;

&lt;p&gt;接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1 也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业 务语义上一定会出现问题，导致各种脏数据的产生。&lt;/p&gt;

&lt;p&gt;所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布 式锁的最大缺陷:在 &lt;strong&gt;redis master&lt;/strong&gt; 实例宕机的时候，可能导致多个客户端同时完成加锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34.&lt;/strong&gt;&lt;strong&gt;使用过&lt;/strong&gt; &lt;strong&gt;Redis&lt;/strong&gt; &lt;strong&gt;分布式锁么，它是怎么实现的?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。 如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样?
 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的!&lt;/p&gt;

&lt;p&gt;35.&lt;strong&gt;使用过&lt;/strong&gt; &lt;strong&gt;Redis&lt;/strong&gt; &lt;strong&gt;做异步队列么，你是怎么用的?有什么缺点?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。
 缺点:
 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。 能不能生产一次消费多次呢?&lt;/p&gt;

&lt;p&gt;使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。&lt;/p&gt;

&lt;p&gt;36.&lt;strong&gt;什么是缓存穿透?如何避免?什么是缓存雪崩?何如避免?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存穿透
 一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找(比如 DB)。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫 做缓存穿透。
 如何避免?
 1:对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理 缓存。
 2:对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过 该 bitmap 过滤。
 缓存雪崩 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压 力。导致系统崩溃。
 如何避免?
 1:在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线 程查询数据和写缓存，其他线程等待。
 2:做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为 短期，A2 设置为长期
 3:不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 和 &lt;strong&gt;memcached&lt;/strong&gt; 什么区别?为什么高并发下有时单线程的 &lt;strong&gt;redis&lt;/strong&gt; 比多线程的 &lt;strong&gt;memcached&lt;/strong&gt; 效率要高?
 区别:
 1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构;&lt;/p&gt;

&lt;p&gt;2.rd 可以使用虚拟内存，rd 可持久化和 aof 灾难恢复，rd 通过主从支持数据备份; 3.rd 可以做消息队列。
 原因:mc 多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 主从复制如何实现的?&lt;strong&gt;redis&lt;/strong&gt; 的集群模式如何实现?&lt;strong&gt;redis&lt;/strong&gt; 的 &lt;strong&gt;key&lt;/strong&gt; 是如何寻址的? 主从复制实现:主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数 据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于 mysql 的二进制日志方 式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。&lt;/p&gt;

&lt;p&gt;分片方式:
 -客户端分片
 -基于代理的分片
 ● Twemproxy
 ● codis
 -路由查询分片
 ● Redis-cluster(本身提供了自动将数据分散到 Redis Cluster 不同节点的能力，整个数据集 合的某个数据子集存储在哪个节点对于用户来说是透明的)&lt;/p&gt;

&lt;p&gt;redis-cluster 分片原理:Cluster 中有一个 16384 长度的槽(虚拟槽)，编号分别为 0-16383。 每个 Master 节点都会负责一部分的槽，当有某个 key 被映射到某个 Master 负责的槽，那 么这个 Master 负责为这个 key 提供服务，至于哪个 Master 节点负责哪个槽，可以由用户 指定，也可以在初始化的时候自动生成，只有 Master 才拥有槽的所有权。Master 节点维 护着一个 16384/8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比 如对于编号为 1 的槽，Master 只要判断序列的第二位(索引从 0 开始)是不是为 1 即可。 这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D, 我需要从节点 A、B、 C 中得部分槽到 D 上。&lt;/p&gt;

&lt;p&gt;使用 &lt;strong&gt;redis&lt;/strong&gt; 如何设计分布式锁?说一下实现思路?使用 &lt;strong&gt;zk&lt;/strong&gt; 可以吗?如何实现?这两种有什 么区别?
 redis:
 1.线程 A setnx(上锁的对象,超时时的时间戳 t1)，如果返回 true，获得锁。&lt;/p&gt;

&lt;p&gt;2.线程 B 用 get 获取 t1,与当前时间戳比较,判断是是否超时,没超时 false,若超时执行第 3 步; 3.计算新的超时时间 t2,使用 getset 命令返回 t3(该值可能其他线程已经修改过),如果 t1==t3，获得锁，如果 t1!=t3 说明锁被其他线程获取了。 4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时， 不用处理(防止删除其他线程的锁)。&lt;/p&gt;

&lt;p&gt;zk:
 1.客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一 的瞬时有序节点 node1; 2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小 的，就认为这个客户端获得了锁。
 3.如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。&lt;/p&gt;

&lt;p&gt;4.获取锁后，处理完逻辑，删除自己创建的 node1 即可。 区别:zk 性能差一些，开销大，实现简单。&lt;/p&gt;

&lt;p&gt;知道 &lt;strong&gt;redis&lt;/strong&gt; 的持久化吗?底层如何实现的?有什么优点缺点?&lt;/p&gt;

&lt;p&gt;RDB(Redis DataBase:在不同的时间点将 redis 的数据生成的快照同步到磁盘等介质上):内存 到硬盘的快照，定期更新。缺点:耗时，耗性能(fork+io 操作)，易丢失数据。
 AOF(Append Only File:将redis所执行过的所有指令都记录下来，在下次redis重启时，只 需要执行指令就可以了):写日志。缺点:体积大，恢复速度慢。&lt;/p&gt;

&lt;p&gt;bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会消耗比较长的时间，不够实 时，在停机的时候会导致大量的数据丢失，需要 aof 来配合，在 redis 实例重启时，优先使 用 aof 来恢复内存的状态，如果没有 aof 日志，就会使用 rdb 文件来恢复。Redis 会定期做 aof 重写，压缩 aof 文件日志大小。Redis4.0 之后有了混合持久化的功能，将 bgsave 的全量 和 aof 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave 的 原理，fork 和 cow, fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据 会逐渐和子进程分离开来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 过期策略都有哪些?&lt;strong&gt;LRU&lt;/strong&gt; 算法知道吗?写一下 &lt;strong&gt;java&lt;/strong&gt; 代码实现?&lt;/p&gt;

&lt;p&gt;过期策略:
 定时过期(一 key 一定时器)，惰性过期:只有使用 key 时才判断 key 是否已过期，过期则清 除。定期过期:前两者折中。
 LRU:new LinkedHashMap&amp;lt;K, V&amp;gt;(capacity, DEFAULT_LOAD_FACTORY, true);
 //第三个参数置为 true，代表 linkedlist 按访问顺序排序，可作为 LRU 缓存;设为 false 代表 按插入顺序排序，可作为 FIFO 缓存
 LRU 算法实现:1.通过双向链表来实现，新数据插入到链表头部;2.每当缓存命中(即缓存 数据被访问)，则将数据移到链表头部;3.当链表满的时候，将链表尾部的数据丢弃。&lt;/p&gt;

&lt;p&gt;LinkedHashMap:HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序 的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插 入顺序(默认)，也可以是访问顺序。&lt;/p&gt;

&lt;p&gt;缓存穿透、缓存击穿、缓存雪崩解决方案?&lt;/p&gt;

&lt;p&gt;缓存穿透:指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将 导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。 解决方案:1.查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短;2.布 隆过滤器:将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对 DB 的查询。&lt;/p&gt;

&lt;p&gt;缓存击穿:对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对 这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并 回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。&lt;/p&gt;

&lt;p&gt;解决方案:1.使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的setnx去设 置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的 方法。2.永远不过期:物理不过期，但逻辑过期(后台异步线程去刷新)。 缓存雪崩:设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部 转发到 DB，DB 瞬时压力过重雪崩。与缓存击穿的区别:雪崩是很多 key，击穿是某一个 key 缓存。 解决方案:将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值， 比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效 的事件。&lt;/p&gt;

&lt;p&gt;在选择缓存时，什么时候选择 &lt;strong&gt;redis&lt;/strong&gt;，什么时候选择 &lt;strong&gt;memcached&lt;/strong&gt; 选择 redis 的情况:&lt;/p&gt;

&lt;p&gt;1、复杂数据结构，value 的数据是哈希，列表，集合，有序集合等这种情况下，会选择 redis, 因为 memcache 无法满足这些数据结构，最典型的的使用场景是，用户订单列表， 用户消息，帖子评论等。&lt;/p&gt;

&lt;p&gt;2、需要进行数据的持久化功能，但是注意，不要把 redis 当成数据库使用，如果 redis 挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有 cache 预热的过 程。对于只读和数据一致性要求不高的场景可以采用持久化存储&lt;/p&gt;

&lt;p&gt;3、高可用，redis 支持集群，可以实现主动复制，读写分离，而对于 memcache 如果想 要实现高可用，需要进行二次开发。&lt;/p&gt;

&lt;p&gt;4、存储的内容比较大，memcache 存储的 value 最大为 1M。 选择 memcache 的场景:&lt;/p&gt;

&lt;p&gt;1、纯 KV,数据量非常大的业务，使用 memcache 更合适，原因是，
 a)memcache 的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时&lt;/p&gt;

&lt;p&gt;间，redis 是临时申请空间，可能导致碎片化。&lt;/p&gt;

&lt;p&gt;b)虚拟内存使用，memcache 将所有的数据存储在物理内存里，redis 有自己的 vm 机 制，理论上能够存储比物理内存更多的数据，当数据超量时，引发 swap,把冷数据刷新到 磁盘上，从这点上，数据量大时，memcache 更快&lt;/p&gt;

&lt;p&gt;c)网络模型，memcache 使用非阻塞的 IO 复用模型，redis 也是使用非阻塞的 IO 复用 模型，但是 redis 还提供了一些非 KV 存储之外的排序，聚合功能，复杂的 CPU 计算，会阻 塞整个 IO 调度，从这点上由于 redis 提供的功能较多，memcache 更快些&lt;/p&gt;

&lt;p&gt;d) 线程模型，memcache使用多线程，主线程监听，worker子线程接受请求，执行 读写，这个过程可能存在锁冲突。redis 使用的单线程，虽然无锁冲突，但是难以利用多核&lt;/p&gt;

&lt;p&gt;的特性提升吞吐量。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;缓存与数据库不一致怎么办
假设采用的主存分离，读写分离的数据库，
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果一个线程 A 先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同 步没有完成，线程 B 从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓 存，这个时候，缓存当中的就是旧的数据。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时
间被拉长了
处理思路:在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了
数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。
主从数据库不一致如何解决
场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的
不一致
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1、忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性 2、强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据&lt;/p&gt;

&lt;p&gt;读取的性能。&lt;/p&gt;

&lt;p&gt;3、选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个 主键，作为缓存的 key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数 据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt; 常见的性能问题和解决方案
 1、master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件 2、如果数据比较重要，某个 slave 开启 AOF 备份，策略设置成每秒同步一次 3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内 4、尽量避免在压力大得主库上增加从库 5、主从复制不要采用网状结构，尽量是线性结构，Master&amp;lt;–Slave1&amp;lt;—-Slave2 ….&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt; 的数据淘汰策略有哪些&lt;/p&gt;

&lt;p&gt;voltile-lru 从已经设置过期时间的数据集中挑选最近最少使用的数据淘汰 voltile-ttl 从已经设置过期时间的数据库集当中挑选将要过期的数据 voltile-random 从已经设置过期时间的数据集任意选择淘汰数据 allkeys-lru 从数据集中挑选最近最少使用的数据淘汰&lt;/p&gt;

&lt;p&gt;allkeys-random 从数据集中任意选择淘汰的数据 no-eviction 禁止驱逐数据
 &lt;strong&gt;Redis&lt;/strong&gt; 当中有哪些数据结构&lt;/p&gt;

&lt;p&gt;字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那 么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、 Geo、Pub/Sub。&lt;/p&gt;

&lt;p&gt;假如 &lt;strong&gt;Redis&lt;/strong&gt; 里面有 &lt;strong&gt;1&lt;/strong&gt; 亿个 &lt;strong&gt;key&lt;/strong&gt;，其中有 &lt;strong&gt;10w&lt;/strong&gt; 个 &lt;strong&gt;key&lt;/strong&gt; 是以某个固定的已知的前缀开头的，如 果将它们全部找出来?&lt;/p&gt;

&lt;p&gt;使用 keys 指令可以扫出指定模式的 key 列表。
 对方接着追问:如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问&lt;/p&gt;

&lt;p&gt;题?&lt;/p&gt;

&lt;p&gt;这个时候你要回答 redis 关键的一个特性:redis 的单线程的。keys 指令会导致线程阻塞一 段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指 令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客 户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。&lt;/p&gt;

&lt;p&gt;使用 &lt;strong&gt;Redis&lt;/strong&gt; 做过异步队列吗，是如何实现的&lt;/p&gt;

&lt;p&gt;使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可 以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没 有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现 一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt; 如何实现延时队列&lt;/p&gt;

&lt;p&gt;使用 sortedset，使用时间戳做 score, 消息内容作为 key,调用 zadd 来生产消息，消费者 使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。&lt;/p&gt;

&lt;h1 id=&quot;redis-1&quot;&gt;Redis&lt;/h1&gt;</content><author><name>tyning.another</name></author><category term="Redis" /><category term="Redis基础" /><summary type="html">Redis 一、redis五种数据类型 一、redis五种数据类型 1. String 最大能存储 512MB 2. list 3. set无序集合 4. zset有顺序不能重复 5. hash数据类型 二、redis集群（多台服务器） 三种模式：主从模式、Sentinel模式（哨兵模式）、Cluster模式 主从：数据库分两类 主数据master库和从数据库slave Sentinel模式（哨兵模式）： 主从复制： 1. redis 是什么？都有哪些使用场景？ Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis 使用场景： 数据高并发的读写 海量数据的读写 对扩展性要求高的数据 2. redis 有哪些功能？ 数据缓存功能 分布式锁的功能 支持数据持久化 支持事务 支持消息队列 3. redis 和 memecache 有什么区别？ memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 redis的速度比memcached快很多 redis可以持久化其数据 4. redis 为什么是单线程的？ 因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。 关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。 5. 什么是缓存穿透？怎么解决？ 缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 6. redis 支持的数据类型有哪些？ string、list、hash、set、zset。 String、List、Set、Sorted Set、hashes 7. redis 支持的 java 客户端都有哪些？ Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 8. jedis 和 redisson 有哪些区别？ Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。 Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 9. 怎么保证缓存和数据库数据的一致性？ 合理设置缓存的过期时间。 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 10. redis 持久化有几种方式？ Redis 的持久化有两种方式，或者说有两种策略： RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。 AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。 11. redis 怎么实现分布式锁？ Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。 占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。 12. redis 分布式锁有什么缺陷？ Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。 13. redis 如何做内存优化？ 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。 14. redis 淘汰策略有哪些？ volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。尝试回收最少使用的键(LRU)，但仅限于在过期集合的键,使得新添加的数据有空间存放。 volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。回收在过期集合的键，并且优先回收存活 时间(TTL)较短的键,使得新添加的数据有空间 存放。 volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。尝试回收最少使用的键(LRU)，使得新添加的数据有空间存放。 allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。回收随机的键使得新添加的数据有空间存放。 no-enviction（驱逐）：禁止驱逐数据。返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。 15. redis 常见的性能问题有哪些？该如何解决？ 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。 Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。 1、 什么是 Redis?简述它的优缺点? Redis 的全称是:Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘 上进行保存。 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。 Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限 制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。 比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高 性能的 tag 系统等等。 另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能 读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。 3、Redis 支持哪几种数据类型? 4、Redis 主要消耗什么物理资源? 内存。 6、Redis 官方为什么不提供 Windows 版本? 因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问 题。 7、一个字符串类型的值能存储最大容量是多少? 512M 8、为什么 Redis 需要把所有数据放到内存中? Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。 所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的 性能。 在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达 到内存限值后不能继续插入新值。 9、Redis 集群方案应该怎么做?都有哪些方案? 1.codis 2.目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点 数据可恢复到新 hash 节点。 redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自 身支持节点设置从节点。具体看官方文档介绍。 3.在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方 案，数据震荡后的自动脚本恢复，实例的监控，等等。 欢迎工作一到五年的 Java 工程师朋友们加入 Java 进阶架构学习交流:952124565，群内提供免费的 Java 架构学习资料(里面有高可用、高并发、高性能及分布式、Jvm 性能调优、Spring 源码， MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx 等多个知识点的架构资 料)合理利用自己每一分每一秒的时间来学习提升自己，不要再用”没有时间“来掩饰自己思想上的懒 惰!趁年轻，使劲拼，给未来的自己一个交代! 10、Redis 集群方案什么情况下会导致整个集群不可用? 有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。 11、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据? redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 其实面试除了考察 Redis，不少公司都很重视高并发高可用的技术，特别是一线互联网公司，分布式、 JVM、spring 源码分析、微服务等知识点已是面试的必考题。我自己整理收集了一套系统的架构技术体 系，针对当前互联网公司的技术需求以及结合主流技术，这些东西可能你们平时在工作中接触过，但是缺 少的全面系统的学习，加入后端开发群:943918498，或是关注微信公众号:Java 资讯库，回复“架 构”，免费领取架构资料。 12、Redis 有哪些适合的场景? (1)会话缓存(Session Cache) 最常用的一种使用 Redis 的情景是会话缓存(sessioncache)，用 Redis 缓存会话比其他存储(如 Memcached)的优势在于:Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的 购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗? 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为 人知的商业平台 Magento 也提供 Redis 的插件。 (2)全页缓存(FPC) 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实 例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快 速度加载你曾浏览过的页面。 (3)队列 Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列 平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言(如 Python)对 list 的 push/pop 操作。 如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的 就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。 (4)排行榜/计数器 Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合(Set)和有序集合(SortedSet)也使 得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。 所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像 下面一样执行即可: 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执 行: ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可 以在这里看到。 (5)发布/订阅 最后(但肯定不是最不重要的)是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见 人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建 立聊天系统! 13、Redis 支持的 Java 客户端都有哪些?官方推荐用哪个? Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。 14、Redis 和 Redisson 有什么关系? Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对 象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。 15、Jedis 与 Redisson 对比有什么优缺点? Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持; Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从 而让使用者能够将精力更集中地放在处理业务逻辑上。 16、说说 Redis 哈希槽的概念? Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通 过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。 17、Redis 集群的主从复制模型是怎样的? 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型, 每个节点都会有 N-1 个复制品. 18、Redis 集群会有写操作丢失吗?为什么? Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 19、Redis 集群之间是如何复制的? 异步复制 20、Redis 集群最大节点个数是多少? 16384 个 21、Redis 集群如何选择数据库? Redis 集群目前无法做数据库选择，默认在 0 数据库。 22、Redis 中的管道有什么用? 一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务 器，而不用等待回复，最后在一个步骤中读取该答复。 这就是管道(pipelining)，是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功 能，大大加快了从服务器下载新邮件的过程。 23、怎么理解 Redis 事务? 事务是一个单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会 被其他客户端发送来的命令请求所打断。 事务是一个原子操作:事务中的命令要么全部被执行，要么全部都不执行。 24、Redis 事务相关的命令有哪几个? MULTI、EXEC、DISCARD、WATCH 25、Redis key 的过期时间和永久有效分别怎么设置? EXPIRE 和 PERSIST 命令 26、Redis 如何做内存优化? 尽可能使用散列表(hashes)，散列表(是说散列表里面存储的数少)使用的内存非常小，所以你应该 尽可能的将你的数据模型抽象到一个散列表里面。 比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是 应该把这个用户的所有信息存储到一张散列表里面。 27、Redis 回收进程如何工作的? 一个客户端运行了新的命令，添加了新的数据。 Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限 制就会被这个内存使用量超越。 28.加锁机制 咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集 群，他首先会根据 hash 节点选择一台机器。这里注意，仅仅只是选择一台机器!这点很关 键!紧接着，就会发送一段 lua 脚本到 redis 上，那段 lua 脚本如下所示: 为啥要用 lua 脚本呢?因为一大坨复杂的业务逻辑，可以通过封装在 lua 脚本中发送给 redis， 保证这段复杂业务逻辑执行的原子性。 那么，这段 lua 脚本是什么意思呢?这里 KEYS[1]代表的是你加锁的那个 key，比如说:RLoc k lock = redisson.getLock(“myLock”);这里你自己设置了加锁的那个锁key就是“myLock”。 ARGV[1]代表的就是锁 key 的默认生存时间，默认 30 秒。ARGV[2]代表的是加锁的客户端的 I D，类似于下面这样:8743c9c0-0795-4907-87fd-6c719a6b4586:1 给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁 的那个锁key不存在的话，你就进行加锁。如何加锁呢?很简单，用下面的命令:hset myLoc k 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1，通过这个命令设置一个hash数据结构，这行 命令执行后，会出现一个类似下面的数据结构: 上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁 key 完 成了加锁。接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间 是 30 秒。好了，到此为止，ok，加锁完成了。 29.锁互斥机制 那么在这个时候，如果客户端 2 来尝试加锁，执行了同样的一段 lua 脚本，会咋样呢?很简 单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。接着第二 个 if 判断，判断一下，myLock 锁 key 的 hash 数据结构中，是否包含客户端 2 的 ID，但是明 显不是的，因为那里包含的是客户端 1 的 ID。 所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key 的剩余生存时间。比如还剩 15000 毫秒的生存时间。此时客户端 2 会进入一个 while 循环，不 停的尝试加锁。 30.watch dog 自动延期机制 客户端 1 加锁的锁 key 默认生存时间才 30 秒，如果超过了 30 秒，客户端 1 还想一直持有这把 锁，怎么办呢? 简单!只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会 每隔 10 秒检查一下，如果客户端 1 还持有锁 key，那么就会不断的延长锁 key 的生存时间。 31.可重入加锁机制 那如果客户端 1 都已经持有了这把锁了，结果可重入的加锁会怎么样呢?比如下面这种代码: 这时我们来分析一下上面那段lua脚本。第一个if判断肯定不成立，“exists myLock”会显示锁 key 已经存在了。第二个 if 判断会成立，因为 myLock 的 hash 数据结构中包含的那个 ID，就 是客户端 1 的那个 ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1” 此时就会执行可重入加锁的逻辑，他会用: incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1 ，通过这个命令，对客户端1 的加锁次数，累加 1。此时 myLock 数据结构变为下面这样: 大家看到了吧，那个 myLock 的 hash 数据结构中的那个客户端 ID，就对应着加锁的次数 32.释放锁机制 如果执行 lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白 了，就是每次都对 myLock 数据结构中的那个加锁次数减 1。如果发现加锁次数是 0 了，说明 这个客户端已经不再持有锁了，此时就会用:“del myLock”命令，从redis里删除这个key。 然后呢，另外的客户端 2 就可以尝试完成加锁了。这就是所谓的分布式锁的开源 Redisson 框 架的实现机制。 一般我们在生产系统中，可以用 Redisson 框架提供的这个类库来基于 redis 进行分布式锁的加 锁与释放锁。 33.上述 Redis 分布式锁的缺点 其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁 key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis m aster宕机，主备切换，redis slave变为了redis master。 接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1 也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业 务语义上一定会出现问题，导致各种脏数据的产生。 所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布 式锁的最大缺陷:在 redis master 实例宕机的时候，可能导致多个客户端同时完成加锁。 34.使用过 Redis 分布式锁么，它是怎么实现的? 先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。 如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样? set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的! 35.使用过 Redis 做异步队列么，你是怎么用的?有什么缺点? 一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。 缺点: 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。 能不能生产一次消费多次呢? 使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。 36.什么是缓存穿透?如何避免?什么是缓存雪崩?何如避免? 缓存穿透 一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找(比如 DB)。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫 做缓存穿透。 如何避免? 1:对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理 缓存。 2:对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过 该 bitmap 过滤。 缓存雪崩 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压 力。导致系统崩溃。 如何避免? 1:在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线 程查询数据和写缓存，其他线程等待。 2:做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为 短期，A2 设置为长期 3:不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀 redis 和 memcached 什么区别?为什么高并发下有时单线程的 redis 比多线程的 memcached 效率要高? 区别: 1.mc 可缓存图片和视频。rd 支持除 k/v 更多的数据结构; 2.rd 可以使用虚拟内存，rd 可持久化和 aof 灾难恢复，rd 通过主从支持数据备份; 3.rd 可以做消息队列。 原因:mc 多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。 redis 主从复制如何实现的?redis 的集群模式如何实现?redis 的 key 是如何寻址的? 主从复制实现:主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数 据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于 mysql 的二进制日志方 式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。 分片方式: -客户端分片 -基于代理的分片 ● Twemproxy ● codis -路由查询分片 ● Redis-cluster(本身提供了自动将数据分散到 Redis Cluster 不同节点的能力，整个数据集 合的某个数据子集存储在哪个节点对于用户来说是透明的) redis-cluster 分片原理:Cluster 中有一个 16384 长度的槽(虚拟槽)，编号分别为 0-16383。 每个 Master 节点都会负责一部分的槽，当有某个 key 被映射到某个 Master 负责的槽，那 么这个 Master 负责为这个 key 提供服务，至于哪个 Master 节点负责哪个槽，可以由用户 指定，也可以在初始化的时候自动生成，只有 Master 才拥有槽的所有权。Master 节点维 护着一个 16384/8 字节的位序列，Master 节点用 bit 来标识对于某个槽自己是否拥有。比 如对于编号为 1 的槽，Master 只要判断序列的第二位(索引从 0 开始)是不是为 1 即可。 这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D, 我需要从节点 A、B、 C 中得部分槽到 D 上。 使用 redis 如何设计分布式锁?说一下实现思路?使用 zk 可以吗?如何实现?这两种有什 么区别? redis: 1.线程 A setnx(上锁的对象,超时时的时间戳 t1)，如果返回 true，获得锁。 2.线程 B 用 get 获取 t1,与当前时间戳比较,判断是是否超时,没超时 false,若超时执行第 3 步; 3.计算新的超时时间 t2,使用 getset 命令返回 t3(该值可能其他线程已经修改过),如果 t1==t3，获得锁，如果 t1!=t3 说明锁被其他线程获取了。 4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时， 不用处理(防止删除其他线程的锁)。 zk: 1.客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一 的瞬时有序节点 node1; 2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小 的，就认为这个客户端获得了锁。 3.如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。 4.获取锁后，处理完逻辑，删除自己创建的 node1 即可。 区别:zk 性能差一些，开销大，实现简单。 知道 redis 的持久化吗?底层如何实现的?有什么优点缺点? RDB(Redis DataBase:在不同的时间点将 redis 的数据生成的快照同步到磁盘等介质上):内存 到硬盘的快照，定期更新。缺点:耗时，耗性能(fork+io 操作)，易丢失数据。 AOF(Append Only File:将redis所执行过的所有指令都记录下来，在下次redis重启时，只 需要执行指令就可以了):写日志。缺点:体积大，恢复速度慢。 bgsave 做镜像全量持久化，aof 做增量持久化。因为 bgsave 会消耗比较长的时间，不够实 时，在停机的时候会导致大量的数据丢失，需要 aof 来配合，在 redis 实例重启时，优先使 用 aof 来恢复内存的状态，如果没有 aof 日志，就会使用 rdb 文件来恢复。Redis 会定期做 aof 重写，压缩 aof 文件日志大小。Redis4.0 之后有了混合持久化的功能，将 bgsave 的全量 和 aof 的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。bgsave 的 原理，fork 和 cow, fork 是指 redis 通过创建子进程来进行 bgsave 操作，cow 指的是 copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据 会逐渐和子进程分离开来。 redis 过期策略都有哪些?LRU 算法知道吗?写一下 java 代码实现? 过期策略: 定时过期(一 key 一定时器)，惰性过期:只有使用 key 时才判断 key 是否已过期，过期则清 除。定期过期:前两者折中。 LRU:new LinkedHashMap&amp;lt;K, V&amp;gt;(capacity, DEFAULT_LOAD_FACTORY, true); //第三个参数置为 true，代表 linkedlist 按访问顺序排序，可作为 LRU 缓存;设为 false 代表 按插入顺序排序，可作为 FIFO 缓存 LRU 算法实现:1.通过双向链表来实现，新数据插入到链表头部;2.每当缓存命中(即缓存 数据被访问)，则将数据移到链表头部;3.当链表满的时候，将链表尾部的数据丢弃。 LinkedHashMap:HashMap 和双向链表合二为一即是 LinkedHashMap。HashMap 是无序 的，LinkedHashMap 通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插 入顺序(默认)，也可以是访问顺序。 缓存穿透、缓存击穿、缓存雪崩解决方案? 缓存穿透:指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将 导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。 解决方案:1.查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短;2.布 隆过滤器:将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据 会被这个 bitmap 拦截掉，从而避免了对 DB 的查询。 缓存击穿:对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对 这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并 回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。 解决方案:1.使用互斥锁:当缓存失效时，不立即去load db，先使用如Redis的setnx去设 置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的 方法。2.永远不过期:物理不过期，但逻辑过期(后台异步线程去刷新)。 缓存雪崩:设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部 转发到 DB，DB 瞬时压力过重雪崩。与缓存击穿的区别:雪崩是很多 key，击穿是某一个 key 缓存。 解决方案:将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值， 比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效 的事件。 在选择缓存时，什么时候选择 redis，什么时候选择 memcached 选择 redis 的情况: 1、复杂数据结构，value 的数据是哈希，列表，集合，有序集合等这种情况下，会选择 redis, 因为 memcache 无法满足这些数据结构，最典型的的使用场景是，用户订单列表， 用户消息，帖子评论等。 2、需要进行数据的持久化功能，但是注意，不要把 redis 当成数据库使用，如果 redis 挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有 cache 预热的过 程。对于只读和数据一致性要求不高的场景可以采用持久化存储 3、高可用，redis 支持集群，可以实现主动复制，读写分离，而对于 memcache 如果想 要实现高可用，需要进行二次开发。 4、存储的内容比较大，memcache 存储的 value 最大为 1M。 选择 memcache 的场景: 1、纯 KV,数据量非常大的业务，使用 memcache 更合适，原因是， a)memcache 的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时 间，redis 是临时申请空间，可能导致碎片化。 b)虚拟内存使用，memcache 将所有的数据存储在物理内存里，redis 有自己的 vm 机 制，理论上能够存储比物理内存更多的数据，当数据超量时，引发 swap,把冷数据刷新到 磁盘上，从这点上，数据量大时，memcache 更快 c)网络模型，memcache 使用非阻塞的 IO 复用模型，redis 也是使用非阻塞的 IO 复用 模型，但是 redis 还提供了一些非 KV 存储之外的排序，聚合功能，复杂的 CPU 计算，会阻 塞整个 IO 调度，从这点上由于 redis 提供的功能较多，memcache 更快些 d) 线程模型，memcache使用多线程，主线程监听，worker子线程接受请求，执行 读写，这个过程可能存在锁冲突。redis 使用的单线程，虽然无锁冲突，但是难以利用多核 的特性提升吞吐量。 缓存与数据库不一致怎么办 假设采用的主存分离，读写分离的数据库， 如果一个线程 A 先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同 步没有完成，线程 B 从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓 存，这个时候，缓存当中的就是旧的数据。 发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时 间被拉长了 处理思路:在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了 数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。 主从数据库不一致如何解决 场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的 不一致 1、忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性 2、强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据 读取的性能。 3、选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个 主键，作为缓存的 key,设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数 据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。 Redis 常见的性能问题和解决方案 1、master 最好不要做持久化工作，如 RDB 内存快照和 AOF 日志文件 2、如果数据比较重要，某个 slave 开启 AOF 备份，策略设置成每秒同步一次 3、为了主从复制的速度和连接的稳定性，master 和 Slave 最好在一个局域网内 4、尽量避免在压力大得主库上增加从库 5、主从复制不要采用网状结构，尽量是线性结构，Master&amp;lt;–Slave1&amp;lt;—-Slave2 …. Redis 的数据淘汰策略有哪些 voltile-lru 从已经设置过期时间的数据集中挑选最近最少使用的数据淘汰 voltile-ttl 从已经设置过期时间的数据库集当中挑选将要过期的数据 voltile-random 从已经设置过期时间的数据集任意选择淘汰数据 allkeys-lru 从数据集中挑选最近最少使用的数据淘汰 allkeys-random 从数据集中任意选择淘汰的数据 no-eviction 禁止驱逐数据 Redis 当中有哪些数据结构 字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。如果是高级用户，那 么还会有，如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、 Geo、Pub/Sub。 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如 果将它们全部找出来? 使用 keys 指令可以扫出指定模式的 key 列表。 对方接着追问:如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问 题? 这个时候你要回答 redis 关键的一个特性:redis 的单线程的。keys 指令会导致线程阻塞一 段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指 令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客 户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。 使用 Redis 做过异步队列吗，是如何实现的 使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可 以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没 有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现 一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。 Redis 如何实现延时队列 使用 sortedset，使用时间戳做 score, 消息内容作为 key,调用 zadd 来生产消息，消费者 使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。 Redis</summary></entry><entry><title type="html">Mysql基础</title><link href="/mysql/2019/05/15/mysql-jichu.html" rel="alternate" type="text/html" title="Mysql基础" /><published>2019-05-15T00:00:00+08:00</published><updated>2019-05-15T00:00:00+08:00</updated><id>/mysql/2019/05/15/mysql-jichu</id><content type="html" xml:base="/mysql/2019/05/15/mysql-jichu.html">&lt;h1 id=&quot;mysql基础&quot;&gt;MySql基础&lt;/h1&gt;

&lt;h2 id=&quot;1-数据库的三范式是什么&quot;&gt;1. 数据库的三范式是什么？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。&lt;/li&gt;
  &lt;li&gt;第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。&lt;/li&gt;
  &lt;li&gt;第三范式：任何非主属性不依赖于其它非主属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-一张自增表里面总共有-7-条数据删除了最后-2-条数据重启-mysql-数据库又插入了一条数据此时-id-是几&quot;&gt;2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;表类型如果是 MyISAM ，那 id 就是 18。&lt;/li&gt;
  &lt;li&gt;表类型如果是 InnoDB，那 id 就是 15。&lt;/li&gt;
  &lt;li&gt;InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-如何获取当前数据库版本&quot;&gt;3. 如何获取当前数据库版本？&lt;/h2&gt;
&lt;p&gt;使用 select version() 获取当前 MySQL 数据库版本。&lt;/p&gt;

&lt;h2 id=&quot;4-说一下-acid-是什么&quot;&gt;4. 说一下 ACID 是什么？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。&lt;/li&gt;
  &lt;li&gt;Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。&lt;/li&gt;
  &lt;li&gt;Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/li&gt;
  &lt;li&gt;Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-char-和-varchar-的区别是什么&quot;&gt;5. char 和 varchar 的区别是什么？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。&lt;/li&gt;
  &lt;li&gt;chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。&lt;/li&gt;
  &lt;li&gt;varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。&lt;/p&gt;

&lt;h2 id=&quot;6-float-和-double-的区别是什么&quot;&gt;6. float 和 double 的区别是什么？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。&lt;/li&gt;
  &lt;li&gt;double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。
    &lt;h2 id=&quot;7-mysql-的内连接左连接右连接有什么区别&quot;&gt;7. mysql 的内连接、左连接、右连接有什么区别？&lt;/h2&gt;
    &lt;p&gt;内连接关键字：inner join；左连接：left join；右连接：right join。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。&lt;/p&gt;

&lt;h2 id=&quot;8-mysql-索引是怎么实现的&quot;&gt;8. mysql 索引是怎么实现的？&lt;/h2&gt;

&lt;p&gt;索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。&lt;/p&gt;

&lt;p&gt;具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。&lt;/p&gt;

&lt;h2 id=&quot;9-怎么验证-mysql-的索引是否满足需求&quot;&gt;9. 怎么验证 mysql 的索引是否满足需求？&lt;/h2&gt;

&lt;p&gt;使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。&lt;/p&gt;

&lt;p&gt;explain 语法：explain select * from table where type=1。&lt;/p&gt;

&lt;h2 id=&quot;10-说一下数据库的事务隔离&quot;&gt;10. 说一下数据库的事务隔离？&lt;/h2&gt;

&lt;p&gt;MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ&lt;/p&gt;

&lt;p&gt;可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。&lt;/p&gt;

&lt;p&gt;不可重复读 ：是指在一个事务内，多次读同一数据。&lt;/p&gt;

&lt;p&gt;幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。&lt;/p&gt;

&lt;h2 id=&quot;11-说一下-mysql-常用的引擎&quot;&gt;11. 说一下 mysql 常用的引擎？&lt;/h2&gt;

&lt;p&gt;InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。&lt;/p&gt;

&lt;p&gt;MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。&lt;/p&gt;

&lt;h2 id=&quot;12-说一下-mysql-的行锁和表锁&quot;&gt;12. 说一下 mysql 的行锁和表锁？&lt;/h2&gt;

&lt;p&gt;MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。&lt;/li&gt;
  &lt;li&gt;行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;13-说一下乐观锁和悲观锁&quot;&gt;13. 说一下乐观锁和悲观锁？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。&lt;/p&gt;

&lt;h2 id=&quot;14-mysql-问题排查都有哪些手段&quot;&gt;14. mysql 问题排查都有哪些手段？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;使用 show processlist 命令查看当前所有连接信息。&lt;/li&gt;
  &lt;li&gt;使用 explain 命令查询 SQL 语句执行计划。&lt;/li&gt;
  &lt;li&gt;开启慢查询日志，查看慢查询的 SQL。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;15-如何做-mysql-的性能优化&quot;&gt;15. 如何做 mysql 的性能优化？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;为搜索字段创建索引。&lt;/li&gt;
  &lt;li&gt;避免使用 select *，列出需要查询的字段。&lt;/li&gt;
  &lt;li&gt;垂直分割分表。&lt;/li&gt;
  &lt;li&gt;选择正确的存储引擎。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>tyning.another</name></author><category term="Mysql" /><category term="Mysql基础" /><summary type="html">MySql基础 1. 数据库的三范式是什么？ 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 第三范式：任何非主属性不依赖于其它非主属性。 2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？ 表类型如果是 MyISAM ，那 id 就是 18。 表类型如果是 InnoDB，那 id 就是 15。 InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。 3. 如何获取当前数据库版本？ 使用 select version() 获取当前 MySQL 数据库版本。 4. 说一下 ACID 是什么？ Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 5. char 和 varchar 的区别是什么？ char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。 chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。 varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。 所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。 6. float 和 double 的区别是什么？ float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。 double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。 7. mysql 的内连接、左连接、右连接有什么区别？ 内连接关键字：inner join；左连接：left join；右连接：right join。 内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。 8. mysql 索引是怎么实现的？ 索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。 9. 怎么验证 mysql 的索引是否满足需求？ 使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。 explain 语法：explain select * from table where type=1。 10. 说一下数据库的事务隔离？ MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。 READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。 REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。 SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。 不可重复读 ：是指在一个事务内，多次读同一数据。 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 11. 说一下 mysql 常用的引擎？ InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。 MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。 12. 说一下 mysql 的行锁和表锁？ MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 13. 说一下乐观锁和悲观锁？ 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。 数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 14. mysql 问题排查都有哪些手段？ 使用 show processlist 命令查看当前所有连接信息。 使用 explain 命令查询 SQL 语句执行计划。 开启慢查询日志，查看慢查询的 SQL。 15. 如何做 mysql 的性能优化？ 为搜索字段创建索引。 避免使用 select *，列出需要查询的字段。 垂直分割分表。 选择正确的存储引擎。</summary></entry><entry><title type="html">Zookeeper</title><link href="/%E5%88%86%E5%B8%83%E5%BC%8F/2019/05/04/zookeeper.html" rel="alternate" type="text/html" title="Zookeeper" /><published>2019-05-04T00:00:00+08:00</published><updated>2019-05-04T00:00:00+08:00</updated><id>/%E5%88%86%E5%B8%83%E5%BC%8F/2019/05/04/zookeeper</id><content type="html" xml:base="/%E5%88%86%E5%B8%83%E5%BC%8F/2019/05/04/zookeeper.html">&lt;h1 id=&quot;一-分布式协调系统&quot;&gt;一、 分布式协调系统&lt;/h1&gt;

&lt;p&gt;Zookeeper属于其中的一种&lt;/p&gt;

&lt;h2 id=&quot;1用于解决什么问题&quot;&gt;1.用于解决什么问题&lt;/h2&gt;

&lt;h2 id=&quot;2如何解决&quot;&gt;2.如何解决&lt;/h2&gt;

&lt;h3 id=&quot;1zab协议的原理&quot;&gt;1.ZAB协议的原理&lt;/h3&gt;

&lt;h3 id=&quot;2cap理论&quot;&gt;2.CAP理论&lt;/h3&gt;

&lt;h2 id=&quot;3安装使用&quot;&gt;3.安装使用&lt;/h2&gt;

&lt;h3 id=&quot;4zookeeper组成&quot;&gt;4.Zookeeper组成&lt;/h3&gt;

&lt;p&gt;1.Znode&lt;/p&gt;

&lt;p&gt;2.运行模式&lt;/p&gt;

&lt;p&gt;单机模式：standalone mode&lt;/p&gt;

&lt;p&gt;复制模式：replicated mode&lt;/p&gt;</content><author><name>tyning.another</name></author><category term="分布式" /><category term="Java" /><category term="分布式" /><category term="Zookeeper" /><summary type="html">一、 分布式协调系统 Zookeeper属于其中的一种 1.用于解决什么问题 2.如何解决 1.ZAB协议的原理 2.CAP理论 3.安装使用 4.Zookeeper组成 1.Znode 2.运行模式 单机模式：standalone mode 复制模式：replicated mode</summary></entry><entry><title type="html">Jvm基础</title><link href="/jvm/2019/05/04/jvm-jichu.html" rel="alternate" type="text/html" title="Jvm基础" /><published>2019-05-04T00:00:00+08:00</published><updated>2019-05-04T00:00:00+08:00</updated><id>/jvm/2019/05/04/jvm-jichu</id><content type="html" xml:base="/jvm/2019/05/04/jvm-jichu.html">&lt;h1 id=&quot;jvm&quot;&gt;JVM&lt;/h1&gt;
&lt;h2 id=&quot;1什么是垃圾&quot;&gt;1.什么是垃圾&lt;/h2&gt;

&lt;p&gt;没有任何引用指向的一个对象或者多个对象（多个对象说的是几个对象相互循环引用）&lt;/p&gt;

&lt;h2 id=&quot;2如何定位垃圾&quot;&gt;2.如何定位垃圾&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;引用计数（ReferenceCount）
    &lt;ol&gt;
      &lt;li&gt;不能解决循环引用的情况&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;根可达算法(RootSearching)
    &lt;ol&gt;
      &lt;li&gt;就是不能够到达根部的对象&lt;/li&gt;
      &lt;li&gt;根部对象是GC roots 有四种：线程栈变量、静态变量、常量池、JNI指针&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;1-说一下-jvm-的主要组成部分及其作用&quot;&gt;1. 说一下 jvm 的主要组成部分？及其作用？&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;类加载器（ClassLoader）&lt;/li&gt;
  &lt;li&gt;运行时数据区（Runtime Data Area）&lt;/li&gt;
  &lt;li&gt;执行引擎（Execution Engine）&lt;/li&gt;
  &lt;li&gt;本地库接口（Native Interface）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。&lt;/p&gt;

&lt;h2 id=&quot;2-说一下-jvm-运行时数据区&quot;&gt;2. 说一下 jvm 运行时数据区？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;程序计数器&lt;/li&gt;
  &lt;li&gt;虚拟机栈&lt;/li&gt;
  &lt;li&gt;本地方法栈&lt;/li&gt;
  &lt;li&gt;堆&lt;/li&gt;
  &lt;li&gt;方法区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。&lt;/p&gt;

&lt;h2 id=&quot;3-说一下堆栈的区别&quot;&gt;3. 说一下堆栈的区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;栈内存存储的是局部变量而堆内存存储的是实体；&lt;/li&gt;
  &lt;li&gt;栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；&lt;/li&gt;
  &lt;li&gt;栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-队列和栈是什么有什么区别&quot;&gt;4. 队列和栈是什么？有什么区别？&lt;/h2&gt;
&lt;p&gt;队列和栈都是被用来预存储数据的。&lt;/p&gt;

&lt;p&gt;队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。&lt;/p&gt;

&lt;p&gt;栈和队列很相似，但它运行对元素进行后进先出进行检索。&lt;/p&gt;

&lt;h2 id=&quot;5-什么是双亲委派模型&quot;&gt;5. 什么是双亲委派模型？&lt;/h2&gt;

&lt;p&gt;在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。&lt;/p&gt;

&lt;p&gt;类加载器分类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他类加载器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=&quot;box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;&quot;&gt;\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；&lt;/java_home&gt;&lt;/li&gt;
  &lt;li&gt;应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;双亲委派模型&lt;/strong&gt;：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。&lt;/p&gt;

&lt;h2 id=&quot;6-说一下类加载的执行过程&quot;&gt;6. 说一下类加载的执行过程？&lt;/h2&gt;
&lt;p&gt;类加载分为以下 5 个步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;加载：根据查找路径找到相应的 class 文件然后导入；&lt;/li&gt;
  &lt;li&gt;检查：检查加载的 class 文件的正确性；&lt;/li&gt;
  &lt;li&gt;准备：给类中的静态变量分配内存空间；&lt;/li&gt;
  &lt;li&gt;解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；&lt;/li&gt;
  &lt;li&gt;初始化：对静态变量和静态代码块执行初始化工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-怎么判断对象是否可以被回收&quot;&gt;7. 怎么判断对象是否可以被回收？&lt;/h2&gt;
&lt;p&gt;一般有两种方法来判断：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/li&gt;
  &lt;li&gt;可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-java-中都有哪些引用类型&quot;&gt;8. java 中都有哪些引用类型？&lt;/h2&gt;
&lt;p&gt;强引用、软引用、弱引用、虚引用（幽灵引用/幻影引用）&lt;/p&gt;
&lt;h2 id=&quot;9-说一下-jvm-有哪些垃圾回收算法&quot;&gt;9. 说一下 jvm 有哪些垃圾回收算法？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;标记-清除算法&lt;/li&gt;
  &lt;li&gt;标记-整理算法&lt;/li&gt;
  &lt;li&gt;复制算法&lt;/li&gt;
  &lt;li&gt;分代算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9-说一下-jvm-有哪些垃圾回收器&quot;&gt;9. 说一下 jvm 有哪些垃圾回收器？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Serial：最早的单线程串行垃圾回收器。&lt;/li&gt;
  &lt;li&gt;Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。&lt;/li&gt;
  &lt;li&gt;ParNew：是 Serial 的多线程版本。&lt;/li&gt;
  &lt;li&gt;Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。&lt;/li&gt;
  &lt;li&gt;Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存-回收算法，Parallel Old 使用的是标记-整理的内存回收算法。&lt;/li&gt;
  &lt;li&gt;CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。&lt;/li&gt;
  &lt;li&gt;G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;10-详细介绍一下-cms-垃圾回收器&quot;&gt;10. 详细介绍一下 CMS 垃圾回收器？&lt;/h2&gt;
&lt;p&gt;CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。&lt;/p&gt;

&lt;p&gt;CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。&lt;/p&gt;

&lt;h2 id=&quot;11新生代垃圾回收器和老生代垃圾回收器都有哪些有什么区别&quot;&gt;11.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;新生代回收器：Serial、ParNew、Parallel Scavenge&lt;/li&gt;
  &lt;li&gt;老年代回收器：Serial Old、Parallel Old、CMS&lt;/li&gt;
  &lt;li&gt;整堆回收器：G1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。&lt;/p&gt;

&lt;h2 id=&quot;12-简述分代垃圾回收器是怎么工作的&quot;&gt;12. 简述分代垃圾回收器是怎么工作的？&lt;/h2&gt;
&lt;p&gt;分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。&lt;/p&gt;

&lt;p&gt;新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;把 Eden + From Survivor 存活的对象放入 To Survivor 区；&lt;/li&gt;
  &lt;li&gt;清空 Eden 和 From Survivor 分区；&lt;/li&gt;
  &lt;li&gt;From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。&lt;/p&gt;

&lt;p&gt;老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。&lt;/p&gt;

&lt;h2 id=&quot;13-说一下-jvm-调优的工具&quot;&gt;13. 说一下 jvm 调优的工具？&lt;/h2&gt;
&lt;p&gt;JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;jconsole：用于对 JVM 中的内存、线程和类等进行监控；&lt;/li&gt;
  &lt;li&gt;jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;14-常用的-jvm-调优的参数都有哪些&quot;&gt;14. 常用的 jvm 调优的参数都有哪些？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;-Xms2g：初始化推大小为 2g；&lt;/li&gt;
  &lt;li&gt;-Xmx2g：堆最大内存为 2g；&lt;/li&gt;
  &lt;li&gt;-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；&lt;/li&gt;
  &lt;li&gt;-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；&lt;/li&gt;
  &lt;li&gt;–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；&lt;/li&gt;
  &lt;li&gt;-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；&lt;/li&gt;
  &lt;li&gt;-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；&lt;/li&gt;
  &lt;li&gt;-XX:+PrintGC：开启打印 gc 信息；&lt;/li&gt;
  &lt;li&gt;-XX:+PrintGCDetails：打印 gc 详细信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cas&quot;&gt;CAS：&lt;/h1&gt;

&lt;p&gt;一、介绍&lt;/p&gt;

&lt;p&gt;cas是compare and swap，比较并且交换。还有一个描述是compare and exchange。在没有锁的情况下保证多个线程多一个资源的更新。&lt;/p&gt;

&lt;p&gt;读取当前值a并记录，然后对a做计算变成b，然后比较记录的a和原来的a作比较是否相等，如果相等就说明没有其他人做修改然后该线程就做更新将a变成b，如果不相等的话就重复这个过程至到修改成功。&lt;/p&gt;

&lt;p&gt;二、其中会有ABA问题，就是将取出来的值a进行计算后的值b后，在做原来值a的比较发现是一样的。但是这种情况下可能已经被改过几次值之后有变为a。&lt;/p&gt;

&lt;p&gt;如何解决ABA问题：可以给原来的值a加上版本号，当取值的时候将版本号也拿上，然后在更新值之前的比较原值的时候也比较版本号，当然更新值的时候也需要将版本号更新了。&lt;/p&gt;

&lt;p&gt;三、CAS的底层实现：是有两个指令lock cmpxchg。这条指令的理解就是需要先加锁lock锁住cmpxchg的整个过程。&lt;/p&gt;

&lt;p&gt;synchronized&lt;/p&gt;</content><author><name>tyning.another</name></author><category term="Jvm" /><category term="Jvm基础" /><summary type="html">JVM 1.什么是垃圾 没有任何引用指向的一个对象或者多个对象（多个对象说的是几个对象相互循环引用） 2.如何定位垃圾 引用计数（ReferenceCount） 不能解决循环引用的情况 根可达算法(RootSearching) 就是不能够到达根部的对象 根部对象是GC roots 有四种：线程栈变量、静态变量、常量池、JNI指针 ## 1. 说一下 jvm 的主要组成部分？及其作用？ 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 2. 说一下 jvm 运行时数据区？ 程序计数器 虚拟机栈 本地方法栈 堆 方法区 有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。 3. 说一下堆栈的区别？ 栈内存存储的是局部变量而堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 4. 队列和栈是什么？有什么区别？ 队列和栈都是被用来预存储数据的。 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。 栈和队列很相似，但它运行对元素进行后进先出进行检索。 5. 什么是双亲委派模型？ 在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 类加载器分类： 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； 其他类加载器： 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库； 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 6. 说一下类加载的执行过程？ 类加载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 检查：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 7. 怎么判断对象是否可以被回收？ 一般有两种方法来判断： 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题； 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 8. java 中都有哪些引用类型？ 强引用、软引用、弱引用、虚引用（幽灵引用/幻影引用） 9. 说一下 jvm 有哪些垃圾回收算法？ 标记-清除算法 标记-整理算法 复制算法 分代算法 9. 说一下 jvm 有哪些垃圾回收器？ Serial：最早的单线程串行垃圾回收器。 Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。 ParNew：是 Serial 的多线程版本。 Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存-回收算法，Parallel Old 使用的是标记-整理的内存回收算法。 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。 10. 详细介绍一下 CMS 垃圾回收器？ CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。 CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。 11.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 12. 简述分代垃圾回收器是怎么工作的？ 分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。 13. 说一下 jvm 调优的工具？ JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。 jconsole：用于对 JVM 中的内存、线程和类等进行监控； jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。 14. 常用的 jvm 调优的参数都有哪些？ -Xms2g：初始化推大小为 2g； -Xmx2g：堆最大内存为 2g； -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4； -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2； –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合； -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合； -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合； -XX:+PrintGC：开启打印 gc 信息； -XX:+PrintGCDetails：打印 gc 详细信息。 CAS： 一、介绍 cas是compare and swap，比较并且交换。还有一个描述是compare and exchange。在没有锁的情况下保证多个线程多一个资源的更新。 读取当前值a并记录，然后对a做计算变成b，然后比较记录的a和原来的a作比较是否相等，如果相等就说明没有其他人做修改然后该线程就做更新将a变成b，如果不相等的话就重复这个过程至到修改成功。 二、其中会有ABA问题，就是将取出来的值a进行计算后的值b后，在做原来值a的比较发现是一样的。但是这种情况下可能已经被改过几次值之后有变为a。 如何解决ABA问题：可以给原来的值a加上版本号，当取值的时候将版本号也拿上，然后在更新值之前的比较原值的时候也比较版本号，当然更新值的时候也需要将版本号更新了。 三、CAS的底层实现：是有两个指令lock cmpxchg。这条指令的理解就是需要先加锁lock锁住cmpxchg的整个过程。 synchronized</summary></entry><entry><title type="html">Java异常</title><link href="/java%E5%BC%82%E5%B8%B8/2019/05/01/java-%E5%BC%82%E5%B8%B8.html" rel="alternate" type="text/html" title="Java异常" /><published>2019-05-01T00:00:00+08:00</published><updated>2019-05-01T00:00:00+08:00</updated><id>/java%E5%BC%82%E5%B8%B8/2019/05/01/java-%E5%BC%82%E5%B8%B8</id><content type="html" xml:base="/java%E5%BC%82%E5%B8%B8/2019/05/01/java-%E5%BC%82%E5%B8%B8.html">&lt;h1 id=&quot;异常&quot;&gt;异常&lt;/h1&gt;
&lt;h2 id=&quot;1-throw-和-throws-的区别&quot;&gt;1. throw 和 throws 的区别？&lt;/h2&gt;
&lt;p&gt;throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。&lt;/p&gt;

&lt;h2 id=&quot;2-finalfinallyfinalize-有什么区别&quot;&gt;2. final、finally、finalize 有什么区别？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。&lt;/li&gt;
  &lt;li&gt;finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。&lt;/li&gt;
  &lt;li&gt;finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-try-catch-finally-中哪个部分可以省略&quot;&gt;3. try-catch-finally 中哪个部分可以省略？&lt;/h2&gt;
&lt;p&gt;catch可以省略&lt;/p&gt;

&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。&lt;/p&gt;

&lt;p&gt;至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。&lt;/p&gt;

&lt;h2 id=&quot;4-try-catch-finally-中如果-catch-中-return-了finally-还会执行吗&quot;&gt;4. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？&lt;/h2&gt;

&lt;p&gt;答：会执行，在 return 前执行。&lt;/p&gt;

&lt;p&gt;代码示例1：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FinallyDemo2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArithmeticException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//      return a;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;执行结果&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码示例2：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.java_02&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FinallyDemo2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ArithmeticException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//      return a;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;执行结果&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5-常见的异常类有哪些&quot;&gt;5. 常见的异常类有哪些？&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;NullPointerException：当应用程序试图访问空对象时，则抛出该异常。&lt;/li&gt;
  &lt;li&gt;SQLException：提供关于数据库访问错误或其他错误信息的异常。&lt;/li&gt;
  &lt;li&gt;IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。&lt;/li&gt;
  &lt;li&gt;NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。&lt;/li&gt;
  &lt;li&gt;FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。&lt;/li&gt;
  &lt;li&gt;IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。&lt;/li&gt;
  &lt;li&gt;ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。&lt;/li&gt;
  &lt;li&gt;ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。&lt;/li&gt;
  &lt;li&gt;IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。&lt;/li&gt;
  &lt;li&gt;ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。&lt;/li&gt;
  &lt;li&gt;NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。&lt;/li&gt;
  &lt;li&gt;NoSuchMethodException：无法找到某一特定方法时，抛出该异常。&lt;/li&gt;
  &lt;li&gt;SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。&lt;/li&gt;
  &lt;li&gt;UnsupportedOperationException：当不支持请求的操作时，抛出该异常。&lt;/li&gt;
  &lt;li&gt;RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>tyning.another</name></author><category term="Java异常" /><category term="Java" /><category term="异常" /><summary type="html">异常 1. throw 和 throws 的区别？ throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。 2. final、finally、finalize 有什么区别？ final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 3. try-catch-finally 中哪个部分可以省略？ catch可以省略 原因： 更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。 至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。 4. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 答：会执行，在 return 前执行。 代码示例1： /* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } // return a; } } 执行结果：30 代码示例2： package com.java_02; /* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; return a; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40 } // return a; } } 执行结果：40 5. 常见的异常类有哪些？ NullPointerException：当应用程序试图访问空对象时，则抛出该异常。 SQLException：提供关于数据库访问错误或其他错误信息的异常。 IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。 IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。 ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。 ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。 IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。 ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。 NoSuchMethodException：无法找到某一特定方法时，抛出该异常。 SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。 UnsupportedOperationException：当不支持请求的操作时，抛出该异常。 RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</summary></entry></feed>